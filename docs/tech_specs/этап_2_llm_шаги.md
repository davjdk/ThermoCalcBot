# Этап 2: LLM шаги (3–4 дня)

**Статус:** Планируется  
**Ответственный:** TBD  
**Зависимости:** Этап 1 (Инфраструктура)

## Цели этапа

Реализовать основные LLM-шаги оркестратора: извлечение параметров, валидация, генерация SQL с валидацией, выполнение SQL. Настроить модели и температуры для каждого шага.

## Задачи

### 1. Создать промпты для новых шагов (`docs/tech_specs/prompts.py`)

**Описание:** Добавить промпты для шагов извлечения, валидации и синтеза ответа. SQL промпт уже существует.

**Промпты для добавления:**

**`extract_inputs_prompt`** - извлечение параметров из пользовательского запроса:
- Анализ intent: fetch/aggregate/thermo_calc/mixed/unknown
- Извлечение entities (названия веществ, формулы)
- Определение phases (s/l/g/aq)
- Извлечение columns (какие данные нужны)
- Определение filters (температура, давление, свойства)
- Определение limits (количество результатов)
- Формирование need_spec (требования к полноте)

**`validate_or_complete_prompt`** - валидация и дополнение параметров:
- Проверка диапазонов температур (реалистичные значения)
- Валидация фаз (s/l/g/aq/a/ai/ao)
- Проверка корректности chemical формул
- Дополнение недостающих логичных параметров
- Разрешение противоречий

**`synthesize_answer_prompt`** - создание итогового ответа:
- Структурированный ответ на русском языке
- Краткое описание найденных данных
- Пометка об усечении при LIMIT
- Интерпретация результатов инструментов
- Рекомендации по дальнейшим действиям

**Требования:**
- Ясные инструкции для модели
- Примеры входа/выхода
- Обработка граничных случаев
- Инструкции по использованию ModelRetry при ошибках

**Файлы:** `docs/tech_specs/prompts.py` (дополнение)

### 2. Реализовать оркестратор (`app/agents/orchestrator_agent.py`)

**Описание:** Создать главный класс оркестратора с реализацией первых 4 шагов из 7.

**Шаги для реализации:**

**`extract_inputs_step(user_text: str) -> ExtractedParams`**
- Использует extract_inputs_prompt
- Модель: MODEL_NAME_EXTRACT (температура 0.2-0.4)
- При неполноте: ModelRetry с перечислением недостающих полей
- Не придумывать факты

**`validate_or_complete_step(params: ExtractedParams) -> ExtractedParams`**
- Использует validate_or_complete_prompt  
- Модель: MODEL_NAME_VALIDATE (температура 0.2-0.4)
- Проверка диапазонов и допустимых значений
- При противоречиях: ModelRetry с инструкцией

**`build_sql_step(params: ExtractedParams) -> SqlCandidate`**
- Использует существующий sql_prompt из prompts.py
- Модель: MODEL_NAME_SQL (температура 0-0.2)
- Генерирует SQL на основе параметров
- Автоматически добавляет LIMIT

**`run_sql_step(sql_candidate: SqlCandidate) -> Rows`**
- Использует db_tools.run_sql()
- Применяет таймауты и лимиты
- Логирует время выполнения
- Измеряет performance метрики

**Основной метод:**
```python
async def run(user_text: str) -> AnswerModel:
    """Основной метод выполнения запроса."""
    # Пока только 4 шага, остальные в следующих этапах
```

**Файлы:** `app/agents/orchestrator_agent.py`

### 3. Создать SQL валидатор с EXPLAIN (`app/agents/tools/sql_validator.py`)

**Описание:** Создать валидатор SQL запросов, который использует EXPLAIN для проверки корректности и инициирует повтор при ошибках.

**Функции:**
```python
class SqlValidator:
    def validate_sql(self, sql: str) -> ValidationResult:
        """Проверка SQL через EXPLAIN"""
        
    def should_retry(self, validation_result: ValidationResult) -> bool:
        """Нужен ли повтор генерации"""
        
    def get_retry_hints(self, validation_result: ValidationResult) -> str:
        """Подсказки для повторной генерации"""
```

**Проверки:**
- EXPLAIN выполняется без ошибок
- Нет DDL/DML операций  
- Корректность имен таблиц и колонок
- Разумность WHERE условий
- Наличие LIMIT

**При ошибке:**
- Возврат к build_sql_step с подсказками
- Максимум 2-3 попытки
- Логирование всех попыток

**Файлы:** `app/agents/tools/sql_validator.py`

### 4. Настроить модели и температуры

**Описание:** Интегрировать настройки моделей в settings.py и оркестратор.

**Настройки моделей:**
- MODEL_NAME_EXTRACT: температура 0.2-0.4 (для точного извлечения)
- MODEL_NAME_VALIDATE: температура 0.2-0.4 (для проверки логики)  
- MODEL_NAME_SQL: температура 0-0.2 (для детерминированного SQL)
- MODEL_NAME_ANSWER: температура 0.3-0.5 (для творческого ответа)

**Таймауты:**
- LLM_TIMEOUT_S: применить ко всем LLM вызовам
- Exponential backoff для повторов
- Graceful degradation при превышении лимитов

**Интеграция:**
- Использовать OpenRouter как провайдер
- Fallback на дефолтную модель при недоступности специфичной
- Логирование использованных моделей и токенов

**Файлы:** `app/config/settings.py`, `app/agents/orchestrator_agent.py`

### 5. Создать инструмент выбора data tools (`app/agents/tools/tool_selector.py`)

**Описание:** Простая логика выбора Python инструментов на основе ключевых слов и контекста.

**Функция:**
```python
def select_data_tools(user_text: str, sql_rows: Rows) -> list[ToolSpec]:
    """Выбор инструментов на основе запроса и данных"""
```

**Стратегия выбора (whitelist):**
- "термодинамическая таблица" / "heat capacity" → thermodynamic_table
- "реакция" / "энтальпия реакции" / "reaction" → reaction_H_S_G_wc  
- Проверка наличия необходимых данных в sql_rows
- Максимум 2 инструмента за запуск

**Безопасность:**
- Белый список разрешенных инструментов
- Валидация аргументов перед выполнением
- Обработка ошибок выполнения

**Файлы:** `app/agents/tools/tool_selector.py`

### 6. Unit тесты для LLM компонентов

**Описание:** Тестирование новых модулей с мокированием LLM вызовов для детерминированности.

**Тесты для SQL валидатора:**
- `test_sql_validator_valid_select()` - принимает корректный SELECT
- `test_sql_validator_blocks_ddl()` - отклоняет CREATE/DROP
- `test_sql_validator_explain_error()` - обрабатывает ошибки EXPLAIN
- `test_sql_validator_retry_hints()` - генерирует подсказки для повтора

**Тесты для tool_selector:**
- `test_select_thermodynamic_tool()` - выбирает термодинамический инструмент  
- `test_select_reaction_tool()` - выбирает инструмент реакции
- `test_whitelist_enforcement()` - соблюдает белый список
- `test_max_tools_limit()` - ограничивает количество инструментов

**Тесты для оркестратора (с моками):**
- `test_extract_inputs_step()` - мок LLM для извлечения параметров
- `test_validate_step()` - мок LLM для валидации  
- `test_build_sql_step()` - мок LLM для генерации SQL
- `test_sql_validation_retry()` - повтор при ошибке валидации

**Файлы:** `tests/test_sql_validator.py`, `tests/test_tool_selector.py`, `tests/test_orchestrator.py`

## Критерии готовности

- ✅ Все новые промпты добавлены в `prompts.py`
- ✅ Оркестратор выполняет 4 шага: extract → validate → build_sql → run_sql
- ✅ SQL валидатор корректно использует EXPLAIN и инициирует повторы
- ✅ Модели и температуры настроены для каждого шага
- ✅ Tool selector выбирает инструменты по whitelist
- ✅ Все unit тесты проходят с мокированными LLM вызовами
- ✅ Логирование работает для всех шагов

## Структура файлов после этапа

```
app/
├── agents/
│   ├── orchestrator_agent.py      # Новый
│   └── tools/
│       ├── sql_validator.py       # Новый
│       └── tool_selector.py       # Новый
docs/
└── tech_specs/
    └── prompts.py                 # Обновлен (добавлены промпты)
tests/
├── test_sql_validator.py          # Новый
├── test_tool_selector.py          # Новый
└── test_orchestrator.py           # Новый
```

## Интеграция с этапом 1

- Использует все модели из `app/agents/models.py`
- Интегрируется с `app/agents/tools/db_tools.py`
- Применяет настройки из обновленного `app/config/settings.py`

## Риски и смягчение

**Риск:** Неточность промптов для извлечения параметров  
**Смягчение:** Итеративная доработка промптов на основе тестовых запросов

**Риск:** Проблемы с повторной генерацией SQL при валидации  
**Смягчение:** Детальные подсказки в SQL валидаторе, лимит попыток

**Риск:** Превышение лимитов API при разработке  
**Смягчение:** Мокирование LLM в тестах, использование дешевых моделей для отладки

**Риск:** Сложность интеграции разных моделей  
**Смягчение:** Единый интерфейс для всех LLM вызовов, fallback механизмы