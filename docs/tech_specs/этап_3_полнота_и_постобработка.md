# Этап 3: Полнота и пост-обработка (2–3 дня)

**Статус:** Планируется  
**Ответственный:** TBD  
**Зависимости:** Этап 2 (LLM шаги)

## Цели этапа

Добавить проверку полноты данных, пост-обработку с Python инструментами и генерацию итогового ответа. Реализовать оставшиеся 3 шага оркестратора.

## Задачи

### 1. Реализовать проверку полноты данных (`ensure_completeness_step`)

**Описание:** Добавить в оркестратор шаг проверки полноты полученных данных и возврат к генерации SQL при недостаточности.

**Функция в оркестраторе:**
```python
def ensure_completeness_step(
    sql_rows: Rows, 
    need_spec: NeedSpec | None
) -> CompletenessResult:
    """Проверка полноты данных согласно требованиям"""
```

**Проверки полноты:**
- **Колонки:** наличие всех required_columns из need_spec
- **Количество строк:** минимум min_rows если указано  
- **Ненулевые поля:** проверка require_non_null полей на отсутствие NULL/пустых значений
- **Качество данных:** проверка на разумность значений (температуры > 0, энтальпии в диапазоне)

**Логика возврата:**
- При fail: возврат к build_sql_step с детальными подсказками
- Максимум 2-3 попытки улучшения SQL
- Подсказки включают: недостающие колонки, нужные фильтры, предложения по JOIN

**Подсказки для SQL:**
- "Добавить колонки: {missing_columns}"
- "Требуется минимум {min_rows} записей, получено {actual_rows}"
- "Поля {null_fields} содержат NULL, добавить фильтр IS NOT NULL"
- "Попробовать менее строгие фильтры для увеличения результатов"

**Файлы:** `app/agents/orchestrator_agent.py` (дополнение)

### 2. Реализовать выбор и выполнение инструментов (`select_and_run_tools_step`)

**Описание:** Добавить в оркестратор шаг выбора Python инструментов и их выполнения на основе данных и запроса.

**Функция в оркестраторе:**
```python
def select_and_run_tools_step(
    user_text: str, 
    sql_rows: Rows
) -> list[ToolRunResult]:
    """Выбор и выполнение инструментов обработки данных"""
```

**Интеграция с tool_selector:**
- Использует `tool_selector.select_data_tools()` из этапа 2
- Применяет usage limits (MAX_TOOL_CALLS)
- Выполняет инструменты последовательно с обработкой ошибок

**Выполнение инструментов:**
```python
def execute_tool(tool_spec: ToolSpec, sql_rows: Rows) -> ToolRunResult:
    """Безопасное выполнение одного инструмента"""
```

**Обработка результатов:**
- Сериализация результатов в JSON-совместимый формат
- Сбор warnings при некорректных входных данных
- Логирование времени выполнения каждого инструмента
- Graceful degradation при ошибках (продолжение без инструмента)

**Поддерживаемые инструменты:**
- `thermodynamic_table`: расчет термодинамических свойств
- `reaction_H_S_G_wc`: расчет энтальпии, энтропии, энергии Гиббса реакции

**Файлы:** `app/agents/orchestrator_agent.py` (дополнение)

### 3. Реализовать синтез итогового ответа (`synthesize_answer_step`)

**Описание:** Создать финальный шаг формирования структурированного ответа на русском языке.

**Функция в оркестраторе:**
```python
def synthesize_answer_step(
    user_text: str,
    sql_rows: Rows,
    tool_results: list[ToolRunResult],
    meta: dict[str, Any]
) -> AnswerModel:
    """Создание итогового ответа пользователю"""
```

**Компоненты ответа:**
- **Основной текст:** краткое описание найденных данных на русском
- **Превью данных:** первые 5-10 строк из sql_rows если есть
- **Результаты инструментов:** интерпретация расчетов и анализа
- **Метаинформация:** время выполнения, использованные модели, ограничения

**Требования к тексту:**
- Максимум max_tokens (из settings)
- Структурированный формат с заголовками
- Пометка об усечении при LIMIT: "Показаны первые {limit} результатов из {total}"
- Рекомендации по уточнению запроса при неполных данных

**Обработка различных сценариев:**
- Пустой результат SQL: "По вашему запросу данные не найдены"
- Ошибки инструментов: пометка о частичных результатах
- Большой объем данных: краткая сводка + превью

**Файлы:** `app/agents/orchestrator_agent.py` (дополнение)

### 4. Завершить основной метод оркестратора

**Описание:** Объединить все 7 шагов в единый workflow основного метода `run()`.

**Полный workflow:**
```python
async def run(user_text: str) -> AnswerModel:
    """Полный цикл обработки запроса (7 шагов)"""
    try:
        # Шаги 1-4 (уже реализованы в этапе 2)
        extracted_params = await self.extract_inputs_step(user_text)
        validated_params = await self.validate_or_complete_step(extracted_params)
        sql_candidate = await self.build_sql_step(validated_params)
        sql_rows = await self.run_sql_step(sql_candidate)
        
        # Шаги 5-7 (новые в этом этапе)
        completeness = self.ensure_completeness_step(sql_rows, validated_params.need_spec)
        
        if not completeness.ok:
            # Повторная генерация SQL с подсказками
            sql_candidate = await self.build_sql_step(validated_params, completeness.hints)
            sql_rows = await self.run_sql_step(sql_candidate)
        
        tool_results = await self.select_and_run_tools_step(user_text, sql_rows)
        answer = await self.synthesize_answer_step(user_text, sql_rows, tool_results, meta)
        
        return answer
        
    except Exception as e:
        # Graceful error handling
        return self.create_error_answer(str(e), user_text)
```

**Обработка ошибок:**
- Try-catch на каждом шаге с продолжением workflow при возможности
- Fallback ответы при критических ошибках
- Детальное логирование для отладки

**Файлы:** `app/agents/orchestrator_agent.py` (завершение)

### 5. Интеграция в main.py

**Описание:** Добавить вызов оркестратора в основной CLI интерфейс.

**Изменения в main.py:**
```python
from app.agents.orchestrator_agent import OrchestratorAgent

async def main():
    """Основная функция CLI"""
    orchestrator = OrchestratorAgent()
    
    while True:
        user_query = input("Введите запрос (или 'exit'): ")
        if user_query.lower() == 'exit':
            break
            
        try:
            answer = await orchestrator.run(user_query)
            print("\n" + "="*50)
            print(answer.text)
            
            if answer.data_preview:
                print(f"\nДанные ({len(answer.data_preview.rows)} строк):")
                # Красивый вывод первых строк
                
            if answer.tool_results:
                print("\nРезультаты анализа:")
                # Вывод результатов инструментов
                
        except Exception as e:
            print(f"Ошибка: {e}")
```

**Альтернативный режим:**
- Флаг `--use-orchestrator` для выбора между старым и новым агентом
- Сохранение существующего функционала для совместимости

**Файлы:** `main.py` (обновление)

### 6. E2E тесты

**Описание:** Создать сквозные тесты для проверки полного цикла работы оркестратора.

**Тест happy path:**
```python
async def test_orchestrator_happy_path():
    """Тест успешного выполнения всех шагов"""
    orchestrator = OrchestratorAgent()
    
    # Запрос, который должен пройти все шаги
    query = "Найди воду в газовой фазе и рассчитай термодинамическую таблицу"
    
    answer = await orchestrator.run(query)
    
    assert answer.text is not None
    assert "H2O" in answer.text or "вода" in answer.text
    assert answer.data_preview is not None
    assert len(answer.tool_results) > 0
```

**Тест неполноты данных:**
```python
async def test_orchestrator_completeness_retry():
    """Тест возврата к генерации SQL при неполных данных"""
    # Запрос, который потребует повторной генерации
    query = "Найди все данные по веществу XYZ123 (несуществующее)"
    
    # Должен корректно обработать отсутствие данных
```

**Тест больших результатов:**
```python
async def test_orchestrator_large_results():
    """Тест обработки большого количества результатов"""
    query = "Найди все газы"
    
    answer = await orchestrator.run(query)
    
    # Должен применить LIMIT и пометить об усечении
    assert "первые" in answer.text.lower() or "показаны" in answer.text.lower()
```

**Файлы:** `tests/test_orchestrator_e2e.py`

## Критерии готовности

- ✅ Проверка полноты данных работает и инициирует повтор SQL при необходимости
- ✅ Python инструменты выбираются и выполняются корректно
- ✅ Итоговый ответ формируется на русском языке со всеми компонентами
- ✅ Полный workflow из 7 шагов выполняется без ошибок
- ✅ Интеграция в main.py позволяет использовать оркестратор через CLI
- ✅ E2E тесты покрывают основные сценарии использования
- ✅ Graceful error handling работает на всех уровнях

## Структура файлов после этапа

```
app/
├── agents/
│   └── orchestrator_agent.py      # Завершен (все 7 шагов)
main.py                            # Обновлен (интеграция оркестратора)
tests/
└── test_orchestrator_e2e.py       # Новый
```

## Интеграция с предыдущими этапами

- Использует все модели и инструменты из этапов 1-2
- Завершает архитектуру оркестратора
- Готовит к финальной полировке в этапе 4

## Риски и смягчение

**Риск:** Сложность интеграции всех шагов в единый workflow  
**Смягчение:** Пошаговая разработка с тестированием каждого добавленного шага

**Риск:** Производительность при выполнении инструментов  
**Смягчение:** Таймауты на выполнение, асинхронное выполнение где возможно

**Риск:** Качество синтеза итогового ответа  
**Смягчение:** Итеративная доработка prompt для synthesize_answer, тестирование на разных типах запросов

**Риск:** Обработка граничных случаев (пустые результаты, ошибки)  
**Смягчение:** Comprehensive error handling, fallback стратегии для всех шагов