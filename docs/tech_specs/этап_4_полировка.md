# Этап 4: Полировка (1–2 дня)

**Статус:** Планируется  
**Ответственный:** TBD  
**Зависимости:** Этап 3 (Полнота и пост-обработка)

## Цели этапа

Завершить разработку оркестратора: добавить мониторинг, логирование, применить usage limits, создать документацию и провести финальную стабилизацию.

## Задачи

### 1. Реализовать системы логирования и метрик

**Описание:** Добавить структурированное логирование и сбор метрик для мониторинга работы оркестратора.

**Логирование (`app/utils/logging.py`):**
```python
import structlog
from app.config.settings import settings

def setup_logging():
    """Настройка структурированного логирования"""
    
def get_logger(name: str):
    """Получить логгер для модуля"""

class OrchestratorLogger:
    """Специализированный логгер для оркестратора"""
    
    def log_step_start(self, step_name: str, input_data: Any):
        """Логирование начала шага"""
        
    def log_step_end(self, step_name: str, duration: float, output_data: Any):
        """Логирование завершения шага"""
        
    def log_model_usage(self, model_name: str, tokens_used: int, cost: float):
        """Логирование использования модели"""
        
    def log_error(self, step_name: str, error: Exception, context: dict):
        """Логирование ошибок с контекстом"""
```

**Метрики для сбора:**
- Время выполнения каждого шага
- Общее время запроса
- Количество использованных токенов по моделям
- Количество строк в SQL результатах
- Количество повторов SQL генерации
- Количество вызовов инструментов
- Успешность выполнения (success rate)

**Формат логов:**
```json
{
  "timestamp": "2025-01-11T10:30:45Z",
  "level": "INFO",
  "step": "extract_inputs",
  "duration_ms": 1200,
  "model": "gpt-4o-mini",
  "tokens_used": 150,
  "user_query_length": 45,
  "extracted_entities": ["H2O", "gas"],
  "request_id": "req_123456"
}
```

**Файлы:** `app/utils/logging.py`, обновление всех модулей оркестратора

### 2. Применить usage limits

**Описание:** Реализовать ограничения на использование ресурсов согласно настройкам.

**Класс Usage Tracker (`app/utils/usage_tracker.py`):**
```python
class UsageTracker:
    """Отслеживание использования ресурсов за один запрос"""
    
    def __init__(self):
        self.model_calls = 0
        self.tool_calls = 0
        self.total_tokens = 0
        self.start_time = time.time()
    
    def increment_model_calls(self, tokens_used: int = 0):
        """Увеличить счетчик вызовов моделей"""
        
    def increment_tool_calls(self):
        """Увеличить счетчик вызовов инструментов"""
        
    def check_limits(self) -> bool:
        """Проверить превышение лимитов"""
        
    def get_usage_summary(self) -> dict:
        """Получить сводку использования"""
```

**Интеграция в оркестратор:**
- Проверка лимитов перед каждым LLM вызовом
- Проверка лимитов перед выполнением инструментов
- Graceful degradation при превышении лимитов
- Включение информации об использовании в итоговый ответ

**Настройки лимитов из settings.py:**
- `MAX_MODEL_CALLS: int = 10` - максимум LLM вызовов за запрос
- `MAX_TOOL_CALLS: int = 3` - максимум инструментов за запрос
- `MAX_TOTAL_TOKENS: int = 50000` - максимум токенов за запрос
- `MAX_REQUEST_TIME_S: int = 30` - максимум времени выполнения

**Файлы:** `app/utils/usage_tracker.py`, обновление `orchestrator_agent.py`

### 3. Создать comprehensive документацию

**Описание:** Документировать архитектуру, API, настройки и инструкции по использованию.

**README обновления:**
```markdown
## Оркестратор-агент

### Быстрый старт
1. Установка зависимостей: `uv sync`
2. Настройка окружения: копировать `.env.example` в `.env`
3. Запуск: `uv run python main.py`

### Использование оркестратора
```bash
# Включить режим оркестратора
uv run python main.py --use-orchestrator

# Примеры запросов
"Найди воду в газовой фазе"
"Рассчитай термодинамическую таблицу для кислорода"
"Найди реакцию хлорирования вольфрама при 600°C"
```

### Архитектура
[Диаграмма 7 шагов с описанием]

### Настройки
[Полное описание всех переменных окружения]
```

**API документация (`docs/api.md`):**
- Описание всех публичных методов
- Схемы входных/выходных данных
- Примеры использования
- Коды ошибок и их обработка

**Конфигурация (`docs/configuration.md`):**
- Подробное описание всех настроек
- Рекомендуемые значения для production/development
- Объяснение влияния каждой настройки на поведение

**Файлы:** `README.md` (обновление), `docs/api.md`, `docs/configuration.md`

### 4. Обновить .env.example с безопасными дефолтами

**Описание:** Создать полный пример конфигурации с комментариями и безопасными значениями.

**Содержимое `.env.example`:**
```bash
# === Основные настройки ===
DATABASE_URL=data/thermo_data.db
DEBUG=false

# === OpenRouter API ===
OPENROUTER_API_KEY=your_api_key_here
MODEL_NAME=anthropic/claude-3-5-haiku-20241022

# === Модели по шагам (опционально) ===
# MODEL_NAME_EXTRACT=anthropic/claude-3-5-haiku-20241022
# MODEL_NAME_VALIDATE=anthropic/claude-3-5-haiku-20241022  
# MODEL_NAME_SQL=anthropic/claude-3-5-haiku-20241022
# MODEL_NAME_ANSWER=anthropic/claude-3-5-haiku-20241022

# === Таймауты (секунды) ===
LLM_TIMEOUT_S=30
DB_TIMEOUT_S=10

# === Лимиты использования ===
MAX_MODEL_CALLS=10
MAX_TOOL_CALLS=3
MAX_TOTAL_TOKENS=50000
MAX_REQUEST_TIME_S=30
MAX_QUERY_RESULTS=100

# === Температуры моделей ===
TEMPERATURE_EXTRACT=0.3
TEMPERATURE_VALIDATE=0.3
TEMPERATURE_SQL=0.1
TEMPERATURE_ANSWER=0.4

# === Логирование ===
LOG_LEVEL=INFO
LOG_FORMAT=json
LOG_FILE=logs/orchestrator.log
```

**Безопасность:**
- Примеры API ключей не содержат реальные значения
- Консервативные лимиты по умолчанию
- Включенные по умолчанию безопасные настройки

**Файлы:** `.env.example`

### 5. Финальная стабилизация тестов

**Описание:** Провести полный проход всех тестов, исправить найденные проблемы, добавить недостающее покрытие.

**Проверка покрытия тестами:**
```bash
# Запуск всех тестов с покрытием
uv run pytest --cov=app --cov-report=html --cov-report=term

# Цель: минимум 80% покрытия для новых модулей
```

**Дополнительные тесты:**
- **Stress тесты:** большие запросы, множественные вызовы
- **Edge cases:** пустые входы, некорректные форматы
- **Error handling:** сетевые ошибки, таймауты
- **Performance:** время выполнения в пределах KPI

**Integration тесты с реальным API:**
```python
@pytest.mark.integration
@pytest.mark.skipif(not settings.OPENROUTER_API_KEY, reason="No API key")
async def test_real_api_integration():
    """Тест с реальным LLM API (под флагом)"""
```

**Smoke тесты:**
```python
def test_orchestrator_imports():
    """Проверка корректности импортов"""
    from app.agents.orchestrator_agent import OrchestratorAgent
    assert OrchestratorAgent is not None

def test_basic_instantiation():
    """Проверка создания экземпляра оркестратора"""
    orchestrator = OrchestratorAgent()
    assert orchestrator is not None
```

**Файлы:** Дополнение всех test файлов, `tests/test_integration.py`

### 6. Performance оптимизация

**Описание:** Провести профилирование и оптимизировать узкие места для соответствия KPI (≤6 секунд).

**Профилирование:**
```python
import cProfile
import pstats

def profile_orchestrator_run():
    """Профилирование полного цикла выполнения"""
    profiler = cProfile.Profile()
    profiler.enable()
    
    # Выполнение типичного запроса
    
    profiler.disable()
    stats = pstats.Stats(profiler)
    stats.sort_stats('cumulative').print_stats(20)
```

**Потенциальные оптимизации:**
- Кэширование результатов EXPLAIN для одинаковых SQL
- Параллельное выполнение независимых инструментов
- Оптимизация промптов для уменьшения токенов
- Connection pooling для БД
- Асинхронные LLM вызовы где возможно

**Бенчмарки:**
- Время выполнения типичных запросов
- Потребление памяти
- Количество API вызовов для стандартных сценариев

**Файлы:** `scripts/benchmark.py`, оптимизации в основных модулях

## Критерии готовности

- ✅ Структурированное логирование работает для всех шагов
- ✅ Usage limits корректно применяются и предотвращают превышение
- ✅ Документация полна и актуальна
- ✅ .env.example содержит все необходимые настройки с безопасными дефолтами
- ✅ Все тесты проходят, покрытие ≥80% для новых модулей
- ✅ Performance соответствует KPI (≤6 секунд для типичных запросов)
- ✅ Интеграционные тесты проходят с реальным API
- ✅ Существующий функционал не сломан (регрессионные тесты)

## Структура файлов после этапа

```
app/
├── utils/
│   ├── logging.py              # Новый
│   └── usage_tracker.py        # Новый
docs/
├── api.md                      # Новый
└── configuration.md            # Новый
scripts/
└── benchmark.py                # Новый
tests/
└── test_integration.py         # Новый
.env.example                    # Обновлен
README.md                       # Обновлен
```

## Финальная готовность продукта

После завершения этого этапа оркестратор-агент будет полностью готов к использованию:

- ✅ Все 7 шагов workflow реализованы и протестированы
- ✅ Безопасность (SQL injection protection, usage limits)
- ✅ Мониторинг (логи, метрики, performance tracking)
- ✅ Документация (API, конфигурация, примеры)
- ✅ Качество (тесты, покрытие, CI/CD готовность)

## Риски и смягчение

**Риск:** Производительность не соответствует KPI  
**Смягчение:** Профилирование и оптимизация критических путей, асинхронность

**Риск:** Логирование влияет на performance  
**Смягчение:** Асинхронное логирование, настраиваемые уровни детализации

**Риск:** Сложность конфигурации для пользователей  
**Смягчение:** Подробная документация, безопасные дефолты, валидация настроек

**Риск:** Регрессии в существующем функционале  
**Смягчение:** Comprehensive регрессионные тесты, поэтапная интеграция