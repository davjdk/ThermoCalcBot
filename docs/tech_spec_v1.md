# ТЗ v1.0: Команда агентов термодинамических расчётов на базе Pydantic AI (без MCP)

Версия: 1.0 (основная). Основано на черновике `tech_spec.md` и возможностях Pydantic AI (agents, tools, dependencies, output, message-history, direct).

См. справочные материалы: `docs/pydantic-ai-ru.md`, https://ai.pydantic.dev/agents/ https://ai.pydantic.dev/tools/ https://ai.pydantic.dev/dependencies/ https://ai.pydantic.dev/output/ https://ai.pydantic.dev/message-history/ https://ai.pydantic.dev/direct/


## 1. Цели и результаты

Функциональные цели:
- Расчёт термодинамических величин для отдельных веществ: Cp(T), ΔH(T), ΔS(T), ΔG(T).
- Расчёт для реакций: балансировка (упрощённая), ΔG(T), ΔH(T), ΔS(T), поиск T_eq (где ΔG≈0).
- Надёжное разрешение веществ: формула → запись БД с учётом фазы и диапазона температур.
- Структурированный результат (Pydantic модели) + краткий вывод на естественном языке.

Нефункциональные:
- Типобезопасность: `deps_type`, типизированные инструменты, валидируемые `output_type` (Pydantic AI Output).
- Локальная БД SQLite (без MCP); путь из `DB_PATH` или `data/thermo_data.db` по умолчанию.
- Наблюдаемость: Pydantic Logfire, учёт usage (tokens/requests/tool calls), сохранение message history при необходимости.
- Кроссплатформенность; локальная разработка — через `uv` и `.env.example`.

Критерии готовности (acceptance):
- Базовые агенты (DB-резолвер, термодинамика, реакции, оркестратор) реализованы на Pydantic AI и проходят юнит‑тесты.
- Для 2 целевых сценариев (из раздела 10) возвращается корректный структурированный ответ и краткое резюме.
- При отсутствии вида/данных — информативная диагностика с альтернативами.


## 2. Данные и допущения

Источник данных: SQLite `data/thermo_data.db` (конфигурируется через `DB_PATH`).
- Основная таблица: `compounds` (см. `docs/db_work.ipynb`). Предполагаемые поля:
  - `Formula`, `Phase` (s|l|g|aq ...), `Tmin`, `Tmax` (K)
  - `H298` (кДж/моль), `S298` (Дж/(моль·К))
  - коэффициенты теплоёмкости `f1..f6`
  - `source`, дополнительные идентификаторы/синонимы.
- Индексы (рекомендация): `(Formula, Phase, Tmin, Tmax)`.
- Математика Cp/H/S/G — как в `docs/сhlorination_of_tungsten.ipynb`: Cp по `f1..f6`, численное интегрирование от T_ref=298.15 K; допускается расчёт вне диапазона с явным флагом.

Ограничения: при неоднозначностях фазы/диапазона агент обязан вернуть предупреждения и диагностические данные.


## 3. Архитектура на Pydantic AI

Паттерн: несколько взаимодополняющих агентов + общий оркестратор.

- Orchestrator Agent
  - Принимает пользовательский запрос, рулит подпроцессами, агрегирует результат.
  - Хранит минимальный контекст разговора через `message_history` между раундами (при необходимости), см. Message History.

- DB & Species Resolver Agent
  - Инструменты: поиск по `Formula`/синонимам, фильтр по `Phase`, выбор записи по T.
  - Политика разрешения: при `T` — запись с `Tmin ≤ T ≤ Tmax`; при множестве — наиболее узкий диапазон; иначе — ближайшие валидные диапазоны (+warn).

- Thermo Agent
  - Инструменты: Cp(T), интегрирование ΔH(T), ΔS(T), вычисление ΔG(T) из H,S; термотаблица по сетке.
  - Валидация T против [Tmin, Tmax] (флаг `in_range`).

- Reactions Agent
  - Балансировка (линейная, упрощённая); суммирование по стехиометрическим коэффициентам; поиск T_eq (бисекция/секущих).

- (Опционально) Explanation Agent
  - Формирует краткий человекочитаемый вывод и сводку источников/диапазонов.

Технические особенности Pydantic AI:
- `Agent[Deps, Output]`: каждый агент объявляет `deps_type` и `output_type`.
- Инструкции: статические (строки) + динамические через `@agent.instructions`.
- Инструменты (tools): через `@agent.tool` (с `RunContext[Deps]`) или `@agent.tool_plain`.
- Структурированный вывод: `output_type` — Pydantic модели/TypedDict/функции; режим по умолчанию — Tool Output.
- Usage limits: ограничение на `tool_calls_limit` и/или токены на ран (во избежание зацикливания).
- Model settings: управление температурой/таймаутами через `ModelSettings` на уровне агента и ран‑ов.


## 4. Контракты инструментов и моделей

Pydantic модели (минимум):
- `SpeciesRecord`:
  - `formula: str`, `phase: str`, `tmin: float`, `tmax: float`,
  - `H298_kJ_per_mol: float`, `S298_J_per_molK: float`,
  - `f1: float` … `f6: float`, `source: str`, `notes: str | None`.
- `ThermoPoint`:
  - `T: float`, `Cp: float`, `H: float`, `S: float`, `G: float`, `in_range: bool`.
- `ThermoRow`:
  - `T: float`, `Cp: float`, `dH: float`, `dS: float`, `dG: float`.
- `Participant`:
  - `name: str`, `formula: str`, `phase: str | None`, `role: Literal['reactant','product']`, `coef: float | None`.
- `ReactionResult`:
  - `dH: float`, `dS: float`, `dG: float`, `feasible_at_T: bool | None`,
  - `T_eq: float | None`, `normalized_per: Literal['per-reaction','per-mol-product']`, `diagnostics: dict`.

Инструменты:
1) `resolve_species(formula: str, phase_hint: str | None, T: float | None, tolerance: float = 1e-6) -> SpeciesRecord`
   - Поиск по `Formula` + карта синонимов; фильтр по фазе; выбор диапазона по T.
   - При отсутствии покрытия по T — вернуть ближайшие диапазоны в `notes` и выставить предупреждения в диагностике.

2) `calculate_thermodynamic_properties(species: SpeciesRecord, T: float) -> ThermoPoint`
   - Ошибка валидации при отсутствии коэффициентов; `in_range=False` при T вне диапазона (расчёт допустим).

3) `thermodynamic_table(species: SpeciesRecord, step: int = 100, round_to: int = 1) -> list[ThermoRow]`
   - Сетка T: `range(ceil(Tmin/step)*step, Tmax, step)` с включением Tmax.

4) `reaction_feasibility(participants: list[Participant], T: float | None, find_T_eq: bool = False, T_bounds: tuple[float, float] | None) -> ReactionResult`
   - Если `coef` не заданы — линейная балансировка по элементам (несколько гипотез для газов/побочных продуктов допустимы и перебираться оркестратором).
   - На заданной T — ΔG/ΔH/ΔS; при `find_T_eq=True` — численный поиск T_eq в `T_bounds`.

5) `species_search(query: str, phase: str | None) -> list[SpeciesRecord] | list[dict]`
   - Возврат кандидатов с оценкой качества совпадения, диапазонами и метаданными.

Примечание о схемах:
- Все параметры инструментов и возвращаемые данные описываются типами; Pydantic AI сгенерирует JSON Schema, а ошибки валидации будут возвращены модели для ретраев (reflection/self-correction).


## 5. Зависимости (DI) и конфигурация

`DBDeps` (dataclass):
- `db_path: str`
- `connection_factory: Callable[[], sqlite3.Connection]`
- `synonyms: dict[str, str]` (нормализация формул, регистр, альтернативы)
- Политика ретраев и кэш курсоров (внутренняя реализация инфраструктурного слоя).

`ThermoDeps` (dataclass):
- `T_ref: float = 298.15`
- `integration_points: int = 400`
- `zero_gibbs_tol: float = 1000.0` (Дж/моль) — допуск «ΔG≈0»

Доступ к зависимостям — через `RunContext[DBDeps|ThermoDeps]` в инструментах/инструкциях/валидаторах вывода.

Переменные окружения:
- `DB_PATH` — путь к БД SQLite; по умолчанию `data/thermo_data.db`.
- Флаги отладки/логирования по необходимости.


## 6. Инфраструктура БД (локальная, без MCP)

- Прямое подключение к SQLite с безопасными значениями по умолчанию.
- Ретраи кратковременных ошибок чтения (например, до 3 попыток, экспоненциальная задержка).
- Кэширование успешных резолвов веществ (LRU/в памяти).
- Карта синонимов формул и нормализация регистра (`Cl2` ≡ `CL2`).
- Диагностика: логирование SQL (через Logfire), фиксация выбранных строк/диапазонов/предупреждений.

Провайдер вида (эскиз интерфейса):
- `get_compounds_by_formula(formula: str) -> list[Row]`
- `search_compounds(query: str, phase: str | None) -> list[Row]`
- `get_species_by_id(id: int) -> Row`


## 7. Алгоритмы и правила

Выбор фазы и диапазона:
- Если фаза указана — использовать её; иначе выбирать стабильную фазу у T (при наличии карты фазовых переходов) либо ближайшие валидные диапазоны.
- При множественных строках одного вещества: приоритет покрывающих T; при равенстве — наиболее узкий диапазон. При отсутствии покрытия — ближайшие с флагом «вне диапазона».

Расчётные формулы:
- Cp по `f1..f6` (как в ноутбуке), интегрирование ΔH, ΔS от T_ref.
- ΔG = H − T·S (в согласованных единицах), храним и возвращаем в Дж/моль; `H298` хранится в кДж/моль — конвертация обязательна.

Реакции:
- Балансировка: линейная по элементам; допускается перебор гипотез (CO/CO2/COCl2/Cl2 и пр.) — оркестратор сравнивает ΔG(T) и выбирает «лучшее».
- Поиск T_eq: бисекция/секущих в заданных границах `T_bounds`; критерий `|ΔG| ≤ zero_gibbs_tol`.
- Признак «возможна при T»: `ΔG(T) < 0` при выбранной нормировке (по умолчанию — «на уравнение» либо «на моль целевого продукта», поле фиксируется в ответе).


## 8. Выводы и форматирование ответа

Pydantic AI Output (по умолчанию Tool Output):
- Для внутренних агентов — типизированные промежуточные модели (см. п.4).
- Для пользовательского ответа — итоговая Pydantic модель, включающая:
  - ключевые численные результаты (kJ/mol для ΔG в резюме, базовые — в Дж/моль),
  - «лучшая» реакция/стехиометрия,
  - `T_eq` (если найдена) и признак осуществимости при заданной T,
  - диагностическая сводка (использованные строки БД, диапазоны, предупреждения),
  - краткий человекочитаемый вывод.

Output validators (по месту): для дополнительной проверяемости чисел/единиц допускается `@agent.output_validator` (или использовать output functions, если требуется дообработка).

Стриминг (опционально): `run_stream()` для текстового вывода; для E2E не обязателен.


## 9. Наблюдаемость, история сообщений и лимиты

- Инструментация: `logfire.instrument_pydantic_ai()`; опционально — логгирование SQLite.
- Usage: сбор `RunUsage` по каждому ран‑у; лимиты `UsageLimits` (например, `tool_calls_limit=8`, ограничение токенов на ответ).
- Message History: при многошаговых разговорах оркестратор может передавать `result.new_messages()` в следующий ран; при необходимости — history processors (обрезка/резюмирование с осторожностью — пары tool call/return должны сохраняться).
- Сохранение истории (опционально): сериализация через `ModelMessagesTypeAdapter` для воспроизводимости.


## 10. Сценарии и ожидаемые ответы (E2E)

1) Хлорирование ZrO2 CCl4
- Кандидатные уравнения (эвристика): образование `ZrCl4(g)`; побочные: `CO/CO2/COCl2`.
- Диапазон T для поиска T_eq: 400–1500 K (пример).
- Ожидаемый итог: JSON‑структура с `best_equation`, `T_eq_K | null`, `dG_at_query_T_kJ_per_mol | null`, `feasible_at_query_T | null`, `confidence`, `diagnostics`.

2) TiO2 + Cl2 при 700°C (973.15 K) в присутствии CH4
- Целевой продукт `TiCl4(g)`, побочные `HCl`, `CO/CO2/H2O` (варианты балансировки).
- Ожидаемый итог: JSON‑структура с `best_equation`, значениями при T=973.15 K и диагностикой выбранных видов/диапазонов.

В обоих случаях при отсутствии вида в БД — явное сообщение, возможные замены (например, смесь CO/CO2) или отказ с причиной.


## 11. Проектная структура (рекомендация)

```
src/
  agents/
    orchestrator.py         # маршрутизация задач, агрегация результатов
    db_agent.py             # инструменты резолвинга веществ
    thermo_agent.py         # Cp, ΔH, ΔS, ΔG, термотаблицы
    reactions_agent.py      # балансировка, ΔG реакции, поиск T_eq
    explain_agent.py        # краткий вывод на естественном языке (опц.)
  domain/
    models.py               # Pydantic модели: SpeciesRecord, ThermoPoint, ...
    thermo.py               # формулы Cp/H/S/G, интегрирование, единицы
    reactions.py            # балансировка, гипотезы, суммирование свойств
  infrastructure/
    db.py                   # фабрика подключений, ретраи, индексы, кэш
    sqlite_provider.py      # конкретные SELECT/поиск/нормализация формул
    config.py               # чтение .env, переменные окружения
app/
  main.py                   # точка входа, старт оркестратора

tests/
  test_resolver.py
  test_thermo.py
  test_reactions.py
  test_e2e_scenarios.py
```

Существующие файлы `main.py`, `check_db.py` можно интегрировать в `app/` и `infrastructure/`.


## 12. Сборка и запуск (Windows PowerShell)

- Управление окружением: `uv`.
- `.env.example`:
  - `DB_PATH=c:\\IDE\\repository\\agents_for_david\\data\\thermo_data.db`

Пример локальной подготовки:
```
powershell
uv venv ; . .\.venv\Scripts\Activate.ps1 ; uv sync
$env:DB_PATH = "c:\\IDE\\repository\\agents_for_david\\data\\thermo_data.db"
python .\main.py
```


## 13. Тестирование

Юнит‑тесты:
- `resolve_species`: точные случаи, множественные диапазоны, вне диапазона.
- `calculate_thermodynamic_properties`: синтетические коэффициенты Cp, проверка интегралов и единиц.
- `reaction_feasibility`: учебные реакции с известным знаком ΔG, проверка поиска T_eq.

Интеграционные:
- Два сценария из п.10 с фиксацией диагностик.

При тестировании агентов — использовать `deps_type` и переопределение зависимостей, ограничивать токены/вызовы инструментов (`UsageLimits`).


## 14. Риски и откат

- Неполная БД — информативный отказ, предложения альтернатив.
- Несогласованность диапазонов/коэф. — явные предупреждения, пометки `in_range`.
- При высоких затратах токенов — `history_processors`, ограничение контекста, снижение температуры/макс. токенов.
- Откат: вся инфраструктура локальна (SQLite), MCP не используется.


## 15. Дорожная карта

1) Этап 1 (эта версия): локальный SQLite, агенты DB/Thermo/Reactions/Orchestrator, E2E для 2 сценариев, базовые тесты, простая диагностика и логирование.
2) Этап 2: улучшение балансировщика, фазовые переходы для отдельных соединений, кэш, профили производительности; опц. streaming UX.
3) Этап 3: расширенная наблюдаемость (Logfire дашборды), более широкие тест‑кейсы, оптимизация SQL/индексов.


## 16. Замечания по реализации Pydantic AI

- Инструкции: предпочитать `instructions` вместо `system_prompt`, динамические инструкции — через `@agent.instructions`.
- Инструменты: описывать параметры и docstring — они попадут в схему; при необходимости — `docstring_format` и `require_parameter_descriptions=True`.
- Вывод: выбирать Tool Output по умолчанию; при сложной пост‑валидации — output functions/validators.
- Сообщения: для продолжения диалога использовать `result.new_messages()`; осторожно с history processors (пары call/return).
- Модель: на уровне проекта выбрать поставщика (OpenAI/Groq/и т.д.) через переменные окружения; для воспроизводимости фиксировать настройки (`ModelSettings`).

---

Примечание: MCP не используется. Провайдер веществ — локальная SQLite; позже может быть расширен при сохранении контрактов API (невмешательство в доменную логику).
