# Pydantic AI — краткая документация на русском

Pydantic AI — это Python-фреймворк для создания агентных систем и приложений на базе генеративных моделей с упором на типобезопасность, структурированный вывод, удобство разработки и наблюдаемость. Проект создан командой Pydantic и наследует принципы эргономики, знакомые по FastAPI: активное использование подсказок типов, строгая валидация данных и понятные контракты интерфейсов.

Основные идеи:
- Модель-агностичный подход: работает с OpenAI, Anthropic, Gemini, DeepSeek, Groq, Cohere, Mistral, Perplexity и многими другими поставщиками и хостингами (Azure, Bedrock, Vertex, Ollama, Together, OpenRouter и др.). Можно реализовать собственную интеграцию модели.
- Типобезопасность и валидируемые контракты: структура ответа описывается через Pydantic-модели; ошибки смещаются из рантайма во время разработки благодаря статической проверке типов.
- Инструменты и DI: функции-инструменты валидируются Pydantic, а зависимости типобезопасно передаются через контекст выполнения.
- Наблюдаемость и производственные практики: готовая интеграция с Pydantic Logfire (OpenTelemetry) для трассировки, мониторинга, оценки качества (evals) и контроля стоимости.
- Дополнительно: потоковая выдача, графы вычислений, долговременное выполнение, MCP/A2A/AG‑UI, ретраи запросов и многое другое.


## Установка

Вы можете установить библиотеку стандартным способом или через uv:

```powershell
# pip
pip install pydantic-ai

# uv (рекомендуется для проектов на uv)
uv add pydantic-ai
```

Дополнительно для конкретного провайдера могут потребоваться переменные окружения (например, ключи API) и/или дополнительные пакеты.


## Базовые понятия

- Agent — основной объект, инкапсулирующий модель, инструкции и опциональные инструменты. Агент можно запускать синхронно или асинхронно.
- Инструкции (instructions) — статические и динамические подсказки модели (system/instructions), определяющие стиль и поведение.
- Инструменты (tools) — функции, которые модель может вызывать для доступа к данным или выполнению действий; аргументы валидируются Pydantic.
- Зависимости (deps) — данные и сервисы, которые вы передаете агенту через типизированный контекст выполнения.
- Структурированный вывод (output_type) — агент гарантированно вернет данные, соответствующие заданной Pydantic‑модели (или повторит попытку при валидационных ошибках).


## Быстрый старт

Минимальный пример, который задает стиль ответа и выполняет один запрос к модели:

```python
from pydantic_ai import Agent

# Явно указываем модель провайдера (можно задать при запуске)
agent = Agent(
    'anthropic:claude-3-5-sonnet-latest',
    instructions='Отвечай кратко одним предложением.'
)

result = agent.run_sync('Откуда пошло выражение «hello world»?')
print(result.output)
```

Аналогично можно использовать асинхронный запуск:

```python
import asyncio
from pydantic_ai import Agent

async def main() -> None:
    agent = Agent('openai:gpt-4o-mini', instructions='Будь краток.')
    res = await agent.run('Привет!')
    print(res.output)

asyncio.run(main())
```


## Инструменты и внедрение зависимостей (DI)

Инструменты описываются как функции; их аргументы валидируются, а зависимости передаются через контекст выполнения `RunContext[Deps]`.

```python
from dataclasses import dataclass
from pydantic import BaseModel, Field
from pydantic_ai import Agent, RunContext

# Зависимости, которые будет видеть агент и инструменты
@dataclass
class SupportDeps:
    customer_id: int
    # Здесь могут быть подключения к БД, API‑клиенты и т.д.

# Структура ответа, которую агент обязан вернуть
class SupportOutput(BaseModel):
    support_advice: str = Field(description='Совет для клиента')
    block_card: bool = Field(description='Нужно ли блокировать карту')
    risk: int = Field(ge=0, le=10, description='Оценка риска')

support_agent = Agent(
    'openai:gpt-4o',
    deps_type=SupportDeps,
    output_type=SupportOutput,
    instructions='Ты сотрудник поддержки банка: помогай клиенту и оценивай риск.'
)

# Динамические инструкции (добавляются к статическим)
@support_agent.instructions
async def add_customer_hint(ctx: RunContext[SupportDeps]) -> str:
    # В реальном коде имя клиента можно добыть из БД по customer_id
    return "Имя клиента — Иван. Отвечай, обращаясь по имени."

# Инструмент, доступный модели
@support_agent.tool
async def customer_balance(
    ctx: RunContext[SupportDeps], include_pending: bool
) -> float:
    """Возвращает текущий баланс клиента. Параметр include_pending включает/исключает незавершенные операции."""
    # Заглушка; в реальности — обращение к внешнему источнику
    return 123.45 if include_pending else 120.00

# Запуск
# deps передаем при каждом запуске; модель сможет вызывать инструменты
# и получит доступ к данным через ctx.deps
# result.output будет иметь тип SupportOutput
```

Ключевые моменты:
- Аргументы инструментов валидируются Pydantic; ошибки возвращаются модели для повторной попытки с корректными аргументами.
- Типизации `RunContext[Deps]` и `output_type` помогают статическому анализу и IDE.
- Зависимости удобны при тестировании/эвалах: можно подменять окружение.


## Структурированный вывод

Задайте `output_type=YourPydanticModel`, и агент вернет строго валидируемую структуру. Если модель сгенерировала некорректные данные, фреймворк инициирует повтор с прояснением требований (reflection/self‑correction), чтобы добиться валидного результата.

Также поддерживается потоковая выдача структурированных результатов: можно получать валидируемые части ответа по мере генерации.


## История сообщений и диалоги

Агенты поддерживают хранение и управление сообщениями, что позволяет строить многошаговые диалоги, сохранять контекст и контролировать, какие части истории передаются в модель.


## Модели и провайдеры

Фреймворк не привязан к одному провайдеру. Из коробки поддерживаются распространенные платформы (OpenAI, Anthropic, Gemini, Mistral, Groq, Cohere и др.), а также хостинги и прокси (Azure, Bedrock, Vertex AI, Ollama, Together, OpenRouter и т.д.).

Если нужного провайдера нет, можно реализовать собственную модель и использовать ее в агенте (кастомные драйверы).


## Наблюдаемость: Pydantic Logfire

Интеграция с Pydantic Logfire (OpenTelemetry) дает:
- трассировку шагов агента и вызовов инструментов;
- отладку и мониторинг производительности;
- метрики стоимости и качества (включая evals);
- автоматическую инструментализацию популярных библиотек (например, БД‑клиентов).

Быстрые шаги:
1) Настройте Logfire в проекте, задайте переменные окружения/проект.
2) Включите инструментирование Pydantic AI (глобально или для конкретного агента).

```python
import logfire

logfire.configure()
logfire.instrument_pydantic_ai()
# Дополнительно — инструментализация конкретных клиентов, например:
# logfire.instrument_asyncpg()
```


## Долговременное выполнение (Durable Execution)

Для долгих и ненадежных процессов есть режим «durable agents», позволяющий:
- переживать временные ошибки API и рестарты приложения;
- продолжать выполнение после сбоев;
- строить человек‑в‑контуре (HITL) и асинхронные сценарии с подтверждениями.


## Потоковые результаты (Streaming)

Агент может выдавать структурированные результаты потоково, валидируя части ответа по мере генерации. Это удобно для UI/чатов и интерактивных сценариев.


## MCP, A2A и AG‑UI

- MCP (Model Context Protocol) — доступ к внешним данным и инструментам через стандартизованный протокол (клиент/сервер).
- A2A (Agent‑to‑Agent) — взаимодействие агентов между собой.
- AG‑UI — компонент для интерактивных приложений с событийной потоковой коммуникацией.


## Эвалы и тестирование

Pydantic AI позволяет систематически оценивать качество агента (evals) и писать тесты, используя те же контракты типов и зависимости. Результаты удобно наблюдать в Logfire.


## Графы (pydantic_graph)

Можно определять ориентированные графы вычислений типами Python. Это помогает строить сложные сценарии без «спагетти‑логики», явно описывая узлы и связи.


## Повторы и устойчивость запросов

Есть встроенная поддержка ретраев HTTP/LLM‑запросов с конфигурацией стратегий и бэк‑оффов.


## Настройки и профили

- Настройки провайдеров и моделей можно задавать в коде и/или через переменные окружения.
- Профили (profiles) помогают переключать окружения (локальная разработка, предпрод, прод) и наборы параметров.


## Практические советы

- Всегда описывайте `output_type` Pydantic‑моделью — это лучший способ зафиксировать контракт и ловить ошибки рано.
- Используйте зависимости (`deps_type` + `RunContext`) вместо глобальных синглтонов — тесты и эволюция кода станут проще.
- Для наблюдаемости включите Logfire с самого начала — это упростит отладку сложных цепочек инструментов.
- Для сложных сценариев разносите логику на несколько инструментов и/или узлов графа.


## Полезные ссылки

- Домашняя страница: https://ai.pydantic.dev/
- Установка: https://ai.pydantic.dev/install/
- Руководства: https://ai.pydantic.dev/agents/
- API Reference (агенты): https://ai.pydantic.dev/api/agent/
- Инструменты: https://ai.pydantic.dev/tools/
- Модели и провайдеры: https://ai.pydantic.dev/models/overview/
- Logfire: https://ai.pydantic.dev/logfire/
- Durable Execution: https://ai.pydantic.dev/durable_execution/overview/
- MCP: https://ai.pydantic.dev/mcp/overview/
- Примеры: https://ai.pydantic.dev/examples/setup/


---

Эта памятка — адаптированный обзор возможностей Pydantic AI на русском языке. За деталями и актуальными API обращайтесь к официальной документации.
