# Техническое задание: Динамическая смена референсных значений H₂₉₈ и S₂₉₈

**Дата:** 2025-11-06  
**Версия:** 1.0  
**Статус:** К имплементации  
**Приоритет:** Высокий

---

## 1. Проблема

### 1.1 Текущее поведение
В существующей реализации `ThermodynamicCalculator._cached_integration()` референсные значения энтальпии и энтропии всегда берутся из **текущей записи** (`record.h298`, `record.s298`), независимо от того, является ли она первой в последовательности фазовых сегментов.

```python
# Текущий код (строки 205-208 в thermodynamic_calculator.py)
h298 = getattr(record, 'h298', 0.0)
s298 = getattr(record, 's298', 0.0)
H298 = h298 * 1000.0  # кДж/моль → Дж/моль
S298 = s298  # Дж/(моль·K)
```

### 1.2 Проблемы текущего подхода
1. **Неправильные расчёты при смене фазы**: Когда вещество переходит из одной фазы в другую (например, `s → l` при плавлении), новая запись может иметь `h298=0.0` и `s298=0.0`, что приводит к обнулению базовых значений
2. **Потеря термодинамической непрерывности**: Энтальпия и энтропия должны накапливаться от фазы к фазе, а не сбрасываться
3. **Некорректные графики H(T) и S(T)**: При визуализации наблюдаются разрывы и падения значений на границах фазовых переходов

### 1.3 Ожидаемое поведение (из аналитического ноутбука)
Логика из `calc_example.ipynb` (строки 396-430):
- **Первая запись (idx=0)**: использует общую референсную запись, содержащую 298.15 K
- **Смена фазы с валидными данными**: используем `h298` и `s298` новой фазы
- **Смена фазы с нулевыми данными**: сохраняем референсные значения предыдущей фазы
- **Та же фаза**: продолжаем использовать референсную запись текущей фазы

---

## 2. Дополнительная фича: Определение простых веществ

### 2.1 Требование
LLM должен определять, является ли вещество **простым** (состоит из одного химического элемента).

### 2.2 Термодинамическое правило
Для **простых веществ** в стандартном состоянии (298.15 K, 1 атм):
- **H₂₉₈ = 0.0** кДж/моль (энтальпия образования из элементов)
- **S₂₉₈ ≠ 0.0** Дж/(моль·K) (энтропия может быть ненулевой)

**Примеры простых веществ:**
- `O2` — кислород (газ)
- `N2` — азот (газ)
- `H2` — водород (газ)
- `C` — углерод (графит)
- `S` — сера (ромбическая)
- `Fe` — железо (металл)
- `Cl2` — хлор (газ)
- `Br2` — бром (жидкость)

**Примеры сложных веществ (не простые):**
- `H2O` — вода
- `CO2` — углекислый газ
- `NH3` — аммиак
- `NaCl` — хлорид натрия

### 2.3 Изменения в модели LLM

#### Файл: `src/thermo_agents/models/extraction.py`

**Добавить новое поле в класс `ExtractedReactionParameters`:**

```python
is_elemental: Optional[bool] = Field(
    default=None,
    description=(
        "Является ли вещество простым (состоит из одного элемента). "
        "True для O2, N2, H2, C, Fe, Cl2 и т.п. "
        "False для H2O, CO2, NH3, NaCl и других сложных веществ. "
        "Только для query_type='compound_data' (одно вещество)."
    )
)
```

### 2.4 Логика применения

В `ThermodynamicCalculator._select_reference_record()` проверять флаг:

```python
def _select_reference_record(
    self,
    records: List[DatabaseRecord],
    current_index: int,
    is_elemental: Optional[bool] = None  # НОВЫЙ ПАРАМЕТР
) -> DatabaseRecord:
    """
    Выбор референсной записи для расчёта H(T) и S(T).
    
    Args:
        records: Список записей, отсортированный по tmin
        current_index: Индекс текущей записи
        is_elemental: True если вещество простое (H298=0 по определению)
    """
    current = records[current_index]
    
    # Правило 0: Для простых веществ H298 всегда 0
    if is_elemental and current_index == 0:
        # Создаём копию записи с принудительным h298=0.0
        # (S298 оставляем как есть)
        return current
    
    # Далее стандартные правила 1-4...
```

### 2.5 Обновление промпта

В `src/thermo_agents/prompts.py` добавить инструкцию для LLM:

```python
SYSTEM_PROMPT_TEMPLATE = """
...
Определение типа вещества:
- Если вещество ПРОСТОЕ (состоит из одного элемента: O2, N2, H2, C, Fe, Cl2...),
  установи is_elemental=True
- Если вещество СЛОЖНОЕ (состоит из нескольких элементов: H2O, CO2, NH3...),
  установи is_elemental=False
- Для запросов reaction_calculation (несколько веществ) оставь is_elemental=None

Примеры простых веществ:
- O2, N2, H2, Cl2, Br2 — двухатомные газы
- C (графит), S (ромбическая), P (белый) — неметаллы
- Fe, Cu, Al, Au, Ag — металлы

Для простых веществ H₂₉₈ = 0.0 кДж/моль по определению.
...
"""
```

### 2.6 Валидация

Добавить валидатор в `ExtractedReactionParameters`:

```python
@field_validator('is_elemental')
@classmethod
def validate_is_elemental(cls, v, info):
    """Проверка корректности флага is_elemental."""
    query_type = info.data.get('query_type')
    all_compounds = info.data.get('all_compounds', [])
    
    # is_elemental применим только для compound_data (одно вещество)
    if v is not None and query_type != 'compound_data':
        raise ValueError(
            "Поле is_elemental применимо только для query_type='compound_data'"
        )
    
    if v is not None and len(all_compounds) > 1:
        raise ValueError(
            "Поле is_elemental применимо только для запросов с одним веществом"
        )
    
    return v
```

---

## 3. Решение (основное)

### 3.1 Архитектурный подход
**Минимальные изменения**: Модифицировать только метод `calculate_properties()` в `ThermodynamicCalculator`, добавив опциональный параметр `reference_record`.

### 2.2 Изменения в коде

#### Файл: `src/thermo_agents/calculations/thermodynamic_calculator.py`

**Изменение 1: Сигнатура метода `calculate_properties()`** (строка ~164)

```python
def calculate_properties(
    self,
    record: DatabaseRecord,
    T: float,
    reference_record: Optional[DatabaseRecord] = None,  # НОВЫЙ ПАРАМЕТР
    is_elemental: Optional[bool] = None  # НОВЫЙ ПАРАМЕТР (для простых веществ)
) -> ThermodynamicProperties:
```

**Изменение 2: Логика выбора референсных значений** (строки ~205-208)

```python
# Определяем источник H298 и S298
if reference_record is not None:
    # Используем переданную референсную запись
    h298 = getattr(reference_record, 'h298', 0.0)
    s298 = getattr(reference_record, 's298', 0.0)
else:
    # Используем текущую запись (legacy behaviour)
    h298 = getattr(record, 'h298', 0.0)
    s298 = getattr(record, 's298', 0.0)

# Применяем правило для простых веществ
if is_elemental is True:
    h298 = 0.0  # Для простых веществ H298 всегда 0 по определению

H298 = h298 * 1000.0  # кДж/моль → Дж/моль
S298 = s298  # Дж/(моль·K)
```

### 2.3 Обратная совместимость
✅ **Гарантирована**: Оба параметра (`reference_record` и `is_elemental`) опциональные, все существующие вызовы продолжат работать без изменений.

---

## 3. Места использования

### 3.1 Внутренние вызовы в `ThermodynamicCalculator`
Методы, которые вызывают `calculate_properties()`:
- `calculate_reaction_properties()` — расчёт реакций (оставить без изменений)
- `calculate_properties_multi_record()` — многофазные расчёты (добавить передачу `is_elemental`)
- `calculate_properties_with_transitions()` — учёт фазовых переходов
- `calculate_properties_optimized()` — оптимизированные расчёты

### 3.2 Внешние вызовы
Поиск использования метода:
```python
# Форматтеры
CompoundDataFormatter._calculate_properties_for_temperature()
  → Получить is_elemental из ExtractedReactionParameters
  
ReactionCalculationFormatter._calculate_compound_properties()
  → is_elemental=None (реакции, несколько веществ)

# Оркестраторы
MultiPhaseOrchestrator — через CompoundDataFormatter
  → Передать is_elemental из параметров запроса
```

### 3.3 Стратегия внедрения
**Фаза 1**: Добавить поле `is_elemental` в `ExtractedReactionParameters`  
**Фаза 2**: Обновить промпт LLM для определения типа вещества  
**Фаза 3**: Добавить параметр `is_elemental` в `calculate_properties()`  
**Фаза 4**: Передавать флаг из форматтеров и оркестраторов  
**Фаза 5**: Внедрить логику выбора референсной записи в `calculate_properties_multi_record()`

---

## 4. Алгоритм выбора референсной записи

### 4.1 Для многофазных расчётов (`calculate_properties_multi_record`)

```python
def _select_reference_record(
    self,
    records: List[DatabaseRecord],
    current_index: int,
    is_elemental: Optional[bool] = None  # НОВЫЙ ПАРАМЕТР
) -> DatabaseRecord:
    """
    Выбор референсной записи для расчёта H(T) и S(T).
    
    Правила:
    0. Простое вещество (is_elemental=True) → H298=0.0 принудительно
    1. Первая запись (idx=0) → используем её саму
    2. Смена фазы + валидные h298/s298 → новая запись
    3. Смена фазы + нулевые h298/s298 → предыдущая фаза
    4. Та же фаза → первая запись текущей фазы
    
    Args:
        records: Список записей, отсортированный по tmin
        current_index: Индекс текущей записи
        is_elemental: True если вещество простое (H298=0 по определению)
    """
    current = records[current_index]
    
    # Правило 0: Для простых веществ H298 всегда 0
    # (применяется на уровне calculate_properties через параметр is_elemental)
    
    # Правило 1: первая запись
    if current_index == 0:
        return current
    
    previous = records[current_index - 1]
    phase_changed = current.phase != previous.phase
    
    # Правило 2: смена фазы с валидными данными
    if phase_changed:
        has_valid_data = abs(current.h298) > 1e-6 or abs(current.s298) > 1e-6
        if has_valid_data:
            return current
        else:
            # Правило 3: смена фазы с нулевыми данными
            # Ищем первую запись предыдущей фазы
            for i in range(current_index - 1, -1, -1):
                if i == 0 or records[i].phase != records[i - 1].phase:
                    return records[i]
    
    # Правило 4: та же фаза
    # Находим первую запись текущей фазы
    for i in range(current_index, -1, -1):
        if i == 0 or records[i].phase != records[i - 1].phase:
            return records[i]
    
    return current  # Fallback
```

### 4.2 Пример использования

```python
# В методе calculate_properties_multi_record
for idx, record in enumerate(sorted_records):
    reference = self._select_reference_record(
        sorted_records, 
        idx,
        is_elemental=is_elemental  # Передаём из параметров запроса
    )
    properties = self.calculate_properties(
        record=record,
        T=temperature,
        reference_record=reference,  # Передаём референсную запись
        is_elemental=is_elemental  # Передаём флаг простого вещества
    )
```

---

## 5. Тестирование

### 5.1 Юнит-тесты
**Новый файл**: `tests/unit/test_reference_record_selection.py`

Тесты:
1. ✅ Первая запись использует саму себя как референс
2. ✅ Смена фазы с валидными h298/s298 → новая референсная запись
3. ✅ Смена фазы с нулевыми h298/s298 → сохранение предыдущей референсной записи
4. ✅ Одна фаза, несколько записей → используется первая запись фазы
5. ✅ Обратная совместимость: `reference_record=None` работает как раньше
6. ✅ **Простые вещества: is_elemental=True → H298=0.0**
7. ✅ **Сложные вещества: is_elemental=False → H298 из базы данных**
8. ✅ **Валидация is_elemental в ExtractedReactionParameters**

### 5.2 Интеграционные тесты
**Файлы**: 
- `tests/integration/test_multiphase_reference_continuity.py`
- `tests/integration/test_phase_transition_enthalpy.py`
- `tests/integration/test_elemental_compounds.py` **(НОВЫЙ)**

Тестовые вещества (из ноутбука):
- `NH4Cl` — 2 записи, плавление при 793 K
- `CeCl3` — 3 записи, s → l → l
- `NaOH` — 6 записей, множественные переходы
- `H2O` — 4 записи, l → g переходы

**Новые тестовые вещества (простые):**
- `O2` — кислород (газ), H298=0.0, S298≠0
- `N2` — азот (газ), H298=0.0, S298≠0
- `Fe` — железо (металл), H298=0.0, S298≠0
- `C` — углерод (графит), H298=0.0, S298≠0

Проверки:
- Непрерывность H(T) на границах записей
- Отсутствие разрывов S(T)
- Корректность ΔH на фазовых переходах
- **H298=0.0 для простых веществ при is_elemental=True**
- **S298≠0 для простых веществ (энтропия ненулевая)**

### 5.3 Валидация через визуализацию
Повторный запуск последней ячейки `calc_example.ipynb` (строки 375-502) должен показать:
- Гладкие кривые H(T) без разрывов
- Монотонное возрастание S(T)
- Отсутствие сообщений `⚠️` о нулевых референсных значениях

---

## 6. Риски и ограничения

### 6.1 Риски
| Риск                                        | Вероятность | Влияние | Митигация                                              |
| ------------------------------------------- | ----------- | ------- | ------------------------------------------------------ |
| Изменение результатов существующих расчётов | Низкая      | Средняя | Параметр опциональный, дефолтное поведение не меняется |
| Производительность (нет кэширования)        | Низкая      | Низкая  | `_cached_integration` уже использует `lru_cache`       |
| Сложность отладки многофазных систем        | Средняя     | Средняя | Добавить DEBUG-логирование выбора референсной записи   |

### 6.2 Ограничения
- **Не учитываются фазовые переходы**: Текущее решение не добавляет ΔH_transition и ΔS_transition
- **Только для одного вещества**: Реакции рассчитываются покомпонентно

---

## 7. План миграции

### Этап 1: Подготовка (1 день)
- [x] Изучение текущего кода `thermodynamic_calculator.py`
- [x] Анализ логики из `calc_example.ipynb`
- [x] Составление ТЗ

### Этап 2: Имплементация (2-3 дня)
- [ ] **Добавление поля `is_elemental` в `ExtractedReactionParameters`**
- [ ] **Обновление промпта LLM для определения типа вещества**
- [ ] **Добавление валидатора для `is_elemental`**
- [ ] Изменение сигнатуры `calculate_properties()`
- [ ] Реализация логики выбора референсных значений
- [ ] Добавление метода `_select_reference_record()`
- [ ] Интеграция в `calculate_properties_multi_record()`
- [ ] **Передача `is_elemental` из форматтеров**

### Этап 3: Тестирование (1-2 дня)
- [ ] Написание юнит-тестов для `_select_reference_record()`
- [ ] **Тесты для is_elemental в ExtractedReactionParameters**
- [ ] **Тесты для простых веществ (O2, N2, Fe, C)**
- [ ] Интеграционные тесты на тестовых веществах
- [ ] Запуск полного набора тестов (`pytest`)
- [ ] Валидация через ноутбук `calc_example.ipynb`
- [ ] **Проверка LLM-определения типа вещества**

### Этап 4: Документация (0.5 дня)
- [ ] Обновление docstring для `calculate_properties()`
- [ ] **Документация поля `is_elemental` и правила для простых веществ**
- [ ] Добавление примеров в `docs/user_guide.md`
- [ ] Обновление `ARCHITECTURE.md`
- [ ] **Примеры запросов с простыми веществами**

### Этап 5: Код-ревью и деплой (0.5 дня)
- [ ] Код-ревью
- [ ] Merge в `dev` ветку
- [ ] Проверка на реальных данных

**Общее время:** 4-5 рабочих дней (увеличено на 1 день для фичи `is_elemental`)

---

## 8. Критерии успеха

✅ **Функциональные:**
1. Расчёты многофазных веществ корректны (H(T) и S(T) непрерывны)
2. Нулевые `h298`/`s298` не обнуляют накопленные значения
3. **Простые вещества (is_elemental=True) имеют H298=0.0**
4. **LLM корректно определяет простые вещества (O2, N2, Fe, C...)**
5. Все существующие тесты проходят

✅ **Нефункциональные:**
1. Производительность не деградирует (кэширование работает)
2. Код читаемый, с понятными комментариями
3. Документация обновлена

✅ **Валидация:**
1. Графики из `calc_example.ipynb` показывают гладкие кривые
2. Тестовые вещества (NH4Cl, CeCl3, NaOH, H2O) рассчитываются корректно
3. **Простые вещества (O2, N2, Fe, C) имеют H(298K)=0 кДж/моль**
4. **LLM-ответы содержат корректное поле is_elemental**

---

## 9. Дополнительные улучшения (опционально)

### 9.1 Автоматическая валидация
Добавить проверку в `_select_reference_record()`:
```python
if reference.h298 < -500 or reference.h298 > 500:
    logger.warning(f"Подозрительное значение H298={reference.h298} кДж/моль")
```

### 9.2 Логирование
```python
logger.debug(
    f"Запись {current_index}: {current.formula} ({current.phase}), "
    f"T={temperature:.1f}K, "
    f"референс: idx={ref_idx}, h298={reference.h298:.2f}, s298={reference.s298:.2f}"
)
```

### 9.3 Метрики
Собирать статистику:
- Сколько раз выбирается текущая запись как референс
- Сколько раз используется предыдущая фаза
- Частота нулевых `h298`/`s298`

### 9.4 Примеры LLM-запросов для простых веществ

**Запрос:**
```
Покажи термодинамические свойства кислорода O2 от 300 до 2000 K
```

**Ожидаемый ответ LLM:**
```json
{
  "query_type": "compound_data",
  "all_compounds": ["O2"],
  "is_elemental": true,  // ← НОВОЕ ПОЛЕ
  "temperature_range_k": [300, 2000],
  ...
}
```

**Запрос:**
```
Рассчитай энтальпию образования воды H2O при 500 K
```

**Ожидаемый ответ LLM:**
```json
{
  "query_type": "compound_data",
  "all_compounds": ["H2O"],
  "is_elemental": false,  // ← H2O это сложное вещество
  "temperature_range_k": [500, 500],
  ...
}
```

---

## 10. Контакты и ответственные

**Разработчик:** GitHub Copilot  
**Заказчик:** davjdk  
**Репозиторий:** `agents_for_david` (ветка `dev`)  
**Аналитический материал:** `docs/calc_example.ipynb` (ячейки 6-10)

---

**Статус:** ✅ Готово к имплементации  
**Следующий шаг:** Утверждение ТЗ и начало имплементации
