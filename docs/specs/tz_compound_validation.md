# Техническое задание: Валидация соединений против уравнения реакции

**Версия:** 1.0  
**Дата:** 2025-10-16  
**Статус:** Черновик  
**Приоритет:** Высокий

---

## 1. Описание проблемы

### 1.1 Текущее состояние

Система выполняет поиск химических соединений на основе префиксного SQL-совпадения (`Formula LIKE 'Mg%'`), что приводит к химически некорректным результатам.

**Пример из логов (session_20251016_121440.log):**

```
Запрос: "Возможно ли взаимодействие TiF4 с Mg при температуре 900-1500K?"
Уравнение: TiF4 + 2Mg → Ti + 2MgF2

Результаты поиска:
  ✅ TiF4 → TiF4(g)        (корректно)
  ❌ Mg   → MgI(g)         (найден йодид магния вместо элементарного Mg)
  ❌ Ti   → Ti(-g)         (найден ион титана вместо металлического Ti)
  ✅ MgF2 → MgF2(s)        (корректно)
```

### 1.2 Корневая причина

- **SQL-поиск:** Использует паттерны типа `Formula LIKE 'Mg%'`, что возвращает MgI, MgBr2, MgF2, и т.д.
- **Отсутствие валидации:** Система не проверяет, соответствует ли найденное соединение роли в уравнении реакции
- **Игнорирование контекста:** LLM извлекает `reactants` и `products`, но система поиска не использует эту информацию

### 1.3 Влияние на систему

- **Некорректные термодинамические расчёты** из-за неправильных соединений
- **Недостоверные результаты** для пользователя
- **Снижение доверия** к системе

---

## 2. Цель

Обеспечить точное соответствие между найденными химическими соединениями и уравнением реакции, предоставленным пользователем.

---

## 3. Требования

### 3.1 Функциональные требования

**FR-1:** Система должна валидировать найденные соединения против уравнения реакции  
**FR-2:** Система должна различать роли соединений (реагент/продукт)  
**FR-3:** Система должна приоритизировать точные совпадения формул над префиксными  
**FR-4:** Система должна логировать несоответствия между найденными и ожидаемыми соединениями  
**FR-5:** Система должна предупреждать пользователя о неполных или некорректных результатах поиска  
**FR-6:** ThermodynamicAgent должен извлекать названия веществ (IUPAC/trivial names) для каждого соединения в реакции  
**FR-7:** ReactionValidator должен использовать названия веществ как дополнительный (не отсекающий) слой валидации для повышения уверенности

### 3.2 Нефункциональные требования

**NFR-1:** Сохранение модульной архитектуры (разделение ответственности между компонентами)  
**NFR-2:** Обратная совместимость с существующими компонентами  
**NFR-3:** Минимальное влияние на производительность (< 5% увеличение времени поиска)  
**NFR-4:** Расширяемость для будущих улучшений

---

## 4. Предлагаемое решение

### 4.1 Архитектурный подход

Введение нового компонента **`ReactionValidator`** на уровне фильтрации, который:

1. Получает результаты поиска от `CompoundSearcher`
2. Сопоставляет найденные соединения с `ExtractedReactionParameters`
3. Валидирует химическое соответствие (точность формул, фазовые состояния)
4. Возвращает отфильтрованные и приоритизированные результаты

### 4.2 Компоненты для изменения

| Компонент                         | Изменение                                                                  | Тип         |
| --------------------------------- | -------------------------------------------------------------------------- | ----------- |
| `models/extraction.py`            | Добавить поле `compound_names: Dict[str, List[str]]` для хранения названий | Модификация |
| `thermodynamic_agent.py`          | Расширить промпт для извлечения IUPAC/trivial names веществ                | Модификация |
| `filtering/reaction_validator.py` | **Новый модуль** для валидации с использованием формул и названий          | Создание    |
| `filtering/filter_pipeline.py`    | Интеграция `ReactionValidator` как Stage 0                                 | Модификация |
| `orchestrator.py`                 | Передача параметров реакции в pipeline                                     | Модификация |
| `search/sql_builder.py`           | Улучшение логики приоритизации точных совпадений                           | Опционально |

### 4.3 Принципиальная схема

```
User Query
    ↓
ThermodynamicAgent (LLM) ✨ ОБНОВЛЕНО
    ↓ ExtractedReactionParameters {
    │   balanced_equation, 
    │   reactants, 
    │   products, 
    │   all_compounds,
    │   compound_names: Dict[str, List[str]]  ← НОВОЕ
    │ }
    ↓
Orchestrator
    ↓
CompoundSearcher (SQL поиск для каждого соединения)
    ↓ List[DatabaseRecord] (необработанные результаты)
    ↓
FilterPipeline
    ↓ Stage 0: ✨ ReactionValidator (НОВЫЙ)
    │   - Проверка точности формул
    │   - Валидация роли (reactant/product)
    │   - Приоритизация элементарных веществ vs сложных
    │   - Сопоставление названий из БД с LLM-извлечёнными (мягкая валидация) ← НОВОЕ
    ↓ Stage 1: ComplexSearchStage
    ↓ Stage 2-5: (существующие)
    ↓
ReactionAggregator
    ↓
Result
```

---

## 5. Детализация извлечения названий веществ

### 5.1 Расширение модели ExtractedReactionParameters

```python
class ExtractedReactionParameters(BaseModel):
    balanced_equation: str
    all_compounds: List[str]
    reactants: List[str]
    products: List[str]
    temperature_range_k: Tuple[float, float]
    extraction_confidence: float
    missing_fields: List[str]
    
    # НОВОЕ ПОЛЕ
    compound_names: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Названия веществ: {формула: [IUPAC name, trivial names...]}"
    )
```

### 5.2 Обновление промпта ThermodynamicAgent

**Текущий промпт** запрашивает: формулы, роли, температуру  
**Расширенный промпт** дополнительно запрашивает:

```
Для каждого вещества в реакции укажите:
1. Химическую формулу (например, TiF4, Mg, MgF2)
2. Официальное IUPAC название (например, Titanium(IV) fluoride)
3. Тривиальные/общепринятые названия, если есть (например, Magnesium)

Формат ответа для compound_names:
{
  "TiF4": ["Titanium(IV) fluoride", "Titanium tetrafluoride"],
  "Mg": ["Magnesium"],
  "MgF2": ["Magnesium fluoride", "Sellaite"]
}
```

### 5.3 Мягкая валидация в ReactionValidator

**Принцип:** Названия из LLM НЕ отсекают результаты, а **повышают confidence score**.

```python
def calculate_name_match_score(
    db_name: str,           # FirstName из базы данных
    llm_names: List[str]    # Названия, извлечённые LLM
) -> float:
    """
    Возвращает score от 0.0 до 1.0:
    - 1.0: точное совпадение с одним из названий LLM
    - 0.5-0.9: частичное совпадение (fuzzy matching)
    - 0.0: нет совпадения (НО запись не отсекается!)
    """
    # Реализация: Levenshtein distance, token matching, etc.
    pass

# Использование в валидаторе:
def validate_compound(formula, db_records, llm_names):
    for record in db_records:
        formula_match_score = check_formula_exact_match(...)  # 0 или 1
        name_match_score = calculate_name_match_score(
            record.FirstName, 
            llm_names.get(formula, [])
        )
        
        # Итоговая уверенность
        total_confidence = (
            0.7 * formula_match_score +  # Формула - главный критерий
            0.3 * name_match_score        # Название - дополнительный
        )
        
        record.validation_confidence = total_confidence
```

### 5.4 Обработка ошибок LLM

**Проблема:** LLM может ошибаться в названиях (галлюцинации, неточности)

**Решение:**
- Если `compound_names` пусто или отсутствует → валидация работает только по формулам (100% формула)
- Если названия заполнены → используются как доп. сигнал (70% формула + 30% название)
- Низкий `name_match_score` НЕ отбрасывает корректную запись по формуле

**Примеры:**
```python
# Кейс 1: LLM правильно извлёк названия
Formula: "Mg"
LLM names: ["Magnesium"]
DB record: FirstName="Magnesium", Formula="Mg(g)"
→ name_match_score = 1.0 ✅ (высокая уверенность)

# Кейс 2: LLM ошибся в названии, но формула точная
Formula: "Ti"
LLM names: ["Titanium metal"]  # не совсем точное название
DB record: FirstName="Titanium", Formula="Ti(s)"
→ name_match_score = 0.6 (частичное совпадение)
→ Всё равно выбирается, т.к. формула точная ✅

# Кейс 3: LLM не предоставил названия
Formula: "MgF2"
LLM names: []
DB record: FirstName="Magnesium fluoride", Formula="MgF2(s)"
→ name_match_score = 0.0 (нет данных)
→ Валидация идёт только по формуле = 100% вес формулы ✅
```

---

## 6. Этапы реализации

### Этап 1: Проектирование (1-2 дня)
- [ ] Детализация спецификации `ReactionValidator`
- [ ] Определение интерфейсов и моделей данных
- [ ] Проектирование тестовых сценариев

### Этап 2: Разработка (3-5 дней)
- [ ] Обновление модели `ExtractedReactionParameters` (добавить `compound_names`)
- [ ] Расширение промпта `ThermodynamicAgent` для извлечения названий веществ
- [ ] Создание модуля `reaction_validator.py` с мягкой валидацией по названиям
- [ ] Интеграция в `FilterPipeline`
- [ ] Обновление `Orchestrator`

### Этап 3: Тестирование (2-3 дня)
- [ ] Unit-тесты для `ReactionValidator` (включая тесты мягкой валидации по названиям)
- [ ] Тесты обработки ошибок LLM (пустые/некорректные названия)
- [ ] Integration-тесты для полного pipeline
- [ ] Тестирование на реальных кейсах из логов

### Этап 4: Документация (1 день)
- [ ] Обновление README
- [ ] Документация API (включая формат `compound_names`)
- [ ] Примеры использования с названиями веществ

---

## 7. Критерии приёмки

**AC-1:** Для запроса "TiF4 + Mg" система находит точные формулы TiF4, Mg (не MgI, MgBr2)  
**AC-2:** Система различает реагенты и продукты в логах  
**AC-3:** ThermodynamicAgent успешно извлекает названия веществ в ≥80% случаев  
**AC-4:** Валидация по названиям повышает confidence score, но НЕ отсекает корректные записи при ошибках LLM  
**AC-5:** Покрытие unit-тестами ≥ 90%  
**AC-6:** Integration-тесты проходят для 5+ реальных реакций  
**AC-7:** Производительность не ухудшается более чем на 5%  
**AC-8:** Логи содержат подробную информацию о валидации (формулы + названия + confidence scores)

---

## 7. Риски и ограничения

### Риски

| Риск                                                      | Вероятность | Влияние | Митигация                                     |
| --------------------------------------------------------- | ----------- | ------- | --------------------------------------------- |
| Сложность химической валидации                            | Средняя     | Высокое | Начать с простых правил, расширять постепенно |
| Ложные негативы (корректные соединения отфильтровываются) | Низкая      | Среднее | Extensive тестирование, настраиваемые пороги  |
| Производительность при большом количестве соединений      | Низкая      | Низкое  | Кэширование, оптимизация алгоритмов           |

### Ограничения

- Решение фокусируется на точности формул, не охватывает стехиометрию
- Валидация применяется только когда LLM успешно извлёк уравнение
- Не исправляет ошибки в базе данных (некорректные формулы)

---

## 8. Альтернативные решения

### Вариант A: Улучшение SQL-запросов
**Описание:** Модифицировать SQL-паттерны для точного совпадения  
**Плюсы:** Минимальные изменения кода  
**Минусы:** Не решает проблему контекста реакции, ограниченная гибкость

### Вариант B: Post-LLM фильтрация в агенте
**Описание:** LLM повторно проверяет найденные соединения  
**Плюсы:** Использует семантическое понимание  
**Минусы:** Высокая стоимость API вызовов, задержка

### Вариант C: ReactionValidator (выбранный) ✅
**Описание:** Детерминированная валидация между поиском и фильтрацией  
**Плюсы:** Оптимальный баланс точности, производительности и стоимости  
**Минусы:** Требует создания нового компонента

---

## 9. Зависимости

- Python 3.10+
- Pydantic (для моделей валидации)
- Существующие компоненты: `FilterPipeline`, `CompoundSearcher`, `ThermodynamicAgent`

---

## 10. Дальнейшее развитие

### Фаза 2 (будущее):
- Валидация стехиометрических коэффициентов
- Проверка законов сохранения массы/заряда
- Интеграция с химическими онтологиями (PubChem, ChEBI)
- ML-модель для ранжирования результатов

### Фаза 3 (будущее):
- Автоматическое исправление ошибок в формулах
- Предложение альтернативных реакций
- Интерактивная валидация с пользователем

---

## Приложения

### A. Примеры валидации

#### A.1 Валидация только по формулам (базовая)

```python
# Кейс 1: Точное совпадение формулы
Input:  formula="Mg", role="reactant"
Found:  ["Mg(g)", "MgI(g)", "MgBr2(g)"]
Result: "Mg(g)" ✅ (элементарный магний, газ)

# Кейс 2: Сложное соединение
Input:  formula="TiF4", role="reactant"
Found:  ["TiF4(g)", "TiF4(l)"]
Result: "TiF4(g)" ✅ (приоритет газовой фазе при высоких T)

# Кейс 3: Продукт
Input:  formula="MgF2", role="product"
Found:  ["MgF2(s)", "MgF2(g)"]
Result: "MgF2(s)" ✅ (твёрдый продукт более вероятен)
```

#### A.2 Валидация с использованием названий (расширенная)

```python
# Кейс 4: Названия повышают уверенность (идеальный случай)
Input:  
  formula="Mg", 
  role="reactant",
  llm_names=["Magnesium"]
  
Found:  
  [
    {"Formula": "Mg(g)", "FirstName": "Magnesium", ...},
    {"Formula": "MgI(g)", "FirstName": "Magnesium monoiodide", ...}
  ]
  
Validation:
  Mg(g):
    - formula_match = 1.0 (точное совпадение "Mg")
    - name_match = 1.0 (точное совпадение "Magnesium")
    - confidence = 0.7*1.0 + 0.3*1.0 = 1.0 ✅ ВЫСОКАЯ
  
  MgI(g):
    - formula_match = 0.0 (не точное совпадение "Mg" ≠ "MgI")
    - name_match = 0.3 (частичное: "Magnesium" содержится)
    - confidence = 0.7*0.0 + 0.3*0.3 = 0.09 ❌ НИЗКАЯ

→ Выбрано: Mg(g) с confidence=1.0

# Кейс 5: LLM ошибся в названии, но формула спасает
Input:  
  formula="Ti", 
  role="product",
  llm_names=["Titan metal"]  # ❌ неправильное название (галлюцинация)
  
Found:  
  [
    {"Formula": "Ti(s)", "FirstName": "Titanium", ...},
    {"Formula": "Ti(-g)", "FirstName": "Titanium -ion", ...}
  ]
  
Validation:
  Ti(s):
    - formula_match = 1.0 (точное совпадение "Ti")
    - name_match = 0.4 (низкое: "Titan metal" vs "Titanium")
    - confidence = 0.7*1.0 + 0.3*0.4 = 0.82 ✅ ДОСТАТОЧНАЯ
  
  Ti(-g):
    - formula_match = 0.0 ("Ti" ≠ "Ti(-g)" - ион)
    - name_match = 0.2 ("Titan" частично похоже на "Titanium")
    - confidence = 0.7*0.0 + 0.3*0.2 = 0.06 ❌ НИЗКАЯ

→ Выбрано: Ti(s) - ошибка LLM не помешала! ✅

# Кейс 6: LLM не предоставил названия
Input:  
  formula="MgF2", 
  role="product",
  llm_names=[]  # пустой список
  
Found:  
  [
    {"Formula": "MgF2(s)", "FirstName": "Magnesium fluoride", ...}
  ]
  
Validation:
  MgF2(s):
    - formula_match = 1.0
    - name_match = 0.0 (нет данных для сравнения)
    - confidence = 0.7*1.0 + 0.3*0.0 = 0.70 ✅ РАБОТАЕТ

→ Система работает без названий (backwards compatible)

# Кейс 7: Множественные названия повышают робастность
Input:  
  formula="TiF4", 
  role="reactant",
  llm_names=["Titanium(IV) fluoride", "Titanium tetrafluoride"]
  
Found:  
  [
    {"Formula": "TiF4(g)", "FirstName": "Titanium tetrafluoride", ...}
  ]
  
Validation:
  - formula_match = 1.0
  - name_match = 1.0 (совпадение со вторым названием в списке)
  - confidence = 1.0 ✅ МАКСИМАЛЬНАЯ
```

#### A.3 Алгоритм сопоставления названий

```python
def calculate_name_match_score(db_name: str, llm_names: List[str]) -> float:
    """
    Fuzzy matching алгоритм для названий.
    
    Проверки (в порядке убывания приоритета):
    1. Точное совпадение (case-insensitive) → 1.0
    2. Совпадение после нормализации (удаление скобок, римских цифр) → 0.9
    3. Token overlap ≥ 80% → 0.7-0.8
    4. Levenshtein distance < 20% → 0.5-0.6
    5. Частичное вхождение → 0.3-0.4
    6. Нет совпадения → 0.0
    """
    if not llm_names:
        return 0.0
    
    db_normalized = normalize_name(db_name)
    scores = []
    
    for llm_name in llm_names:
        llm_normalized = normalize_name(llm_name)
        
        # 1. Точное совпадение
        if db_normalized.lower() == llm_normalized.lower():
            scores.append(1.0)
            continue
        
        # 2. Совпадение без специальных символов
        db_clean = remove_special_chars(db_normalized)
        llm_clean = remove_special_chars(llm_normalized)
        if db_clean == llm_clean:
            scores.append(0.9)
            continue
        
        # 3. Token overlap
        db_tokens = set(db_clean.split())
        llm_tokens = set(llm_clean.split())
        overlap = len(db_tokens & llm_tokens) / len(db_tokens | llm_tokens)
        if overlap >= 0.8:
            scores.append(0.7 + overlap * 0.1)
            continue
        
        # 4. Levenshtein distance
        # ... (опционально для более сложных случаев)
    
    return max(scores) if scores else 0.0
```

### B. Ссылки на лог-файлы

- `logs/sessions/session_20251016_121440.log` - пример проблемного случая

---

**Подписи:**

Автор: GitHub Copilot  
Рецензент: _[Ожидает согласования]_  
Утверждено: _[Ожидает утверждения]_
