# ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ¸ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹

**ĞŸÑ€Ğ¾ĞµĞºÑ‚:** ThermoSystem Telegram Bot Integration
**Ğ’ĞµÑ€ÑĞ¸Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°:** 1.1
**Ğ”Ğ°Ñ‚Ğ°:** 9 Ğ½Ğ¾ÑĞ±Ñ€Ñ 2025

---

## ğŸ—ï¸ 1. ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ½Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

### 1.1. ĞĞ±Ñ‰Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ğ°Ñ Ğ´Ğ¸Ğ°Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Telegram Bot API                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                ThermoSystemTelegramBot                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  MessageHandler â”‚  â”‚  CommandHandler â”‚  â”‚ ResponseFormatterâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  SessionManager â”‚  â”‚  RateLimiter    â”‚  â”‚  ErrorHandler   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  FileHandler    â”‚  â”‚ SmartResponse   â”‚  â”‚  HealthChecker  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ThermoOrchestrator v2.2                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ThermodynamicAgentâ”‚  â”‚  Search System  â”‚  â”‚Calculation Engineâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Data Loading   â”‚  â”‚  Filtering      â”‚  â”‚  Formatting     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚thermo_data.db   â”‚              â”‚YAML ĞºÑÑˆ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²  â”‚          â”‚
â”‚  â”‚   316K Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹  â”‚              â”‚   Ñ€Ğ°ÑĞ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½Ñ‘Ğ½ â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚   Ğ½Ñ‹Ñ… Ğ²ĞµÑ‰ĞµÑÑ‚Ğ²    â”‚          â”‚
â”‚                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2. Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ Telegram Ğ±Ğ¾Ñ‚Ğ°

```
src/thermo_agents/telegram_bot/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ bot.py                     # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ»Ğ°ÑÑ Ğ±Ğ¾Ñ‚Ğ°
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ message_handler.py     # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
â”‚   â”œâ”€â”€ bot_command_handlers.py # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ (/start, /help)
â”‚   â””â”€â”€ callback_handler.py    # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° inline ĞºĞ½Ğ¾Ğ¿Ğ¾Ğº
â”œâ”€â”€ formatters/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ telegram_formatter.py  # ĞĞ´Ğ°Ğ¿Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ° Ğ´Ğ»Ñ Telegram
â”‚   â””â”€â”€ message_splitter.py    # Ğ Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ğ¸Ğ½Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
â”œâ”€â”€ managers/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ session_manager.py     # Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞµÑÑĞ¸ÑĞ¼Ğ¸ Ğ±Ğ¾Ñ‚Ğ°
â”‚   â”œâ”€â”€ rate_limiter.py        # ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²
â”‚   â”œâ”€â”€ file_handler.py        # Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¼Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°Ğ¼Ğ¸
â”‚   â””â”€â”€ smart_response.py      # Ğ£Ğ¼Ğ½Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° (ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ/Ñ„Ğ°Ğ¹Ğ»)
â”œâ”€â”€ config.py                  # ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ°
â””â”€â”€ utils.py                   # Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹ Ğ´Ğ»Ñ Telegram
```

### 1.3. ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹

#### 1.3.1. ThermoSystemTelegramBot (ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ»Ğ°ÑÑ)

**ĞÑ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸:**
- Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Telegram Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
- ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¾Ğ² ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ Ğ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
- Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¶Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ñ‹Ğ¼ Ñ†Ğ¸ĞºĞ»Ğ¾Ğ¼ Ğ±Ğ¾Ñ‚Ğ°
- Graceful shutdown

**ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹:**
```python
class ThermoSystemTelegramBot:
    def __init__(self, config: TelegramBotConfig)
    def _setup_handlers(self) -> None
    async def start(self) -> None
    async def shutdown(self) -> None
    async def health_check(self) -> dict
```

#### 1.3.2. MessageHandler (ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹)

**ĞÑ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸:**
- ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
- Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ ThermoOrchestrator
- ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¿Ñ€Ğ¾Ğ³Ñ€ĞµÑÑ Ğ¸Ğ½Ğ´Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²
- Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Telegram

**ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹:**
```python
class TelegramMessageHandler:
    async def handle_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE)
    async def _send_typing_indicator(self, chat_id: int, context: ContextTypes.DEFAULT_TYPE)
    async def _handle_calculation_response(self, update: Update, response: str, context: ContextTypes.DEFAULT_TYPE)
```

#### 1.3.3. CommandHandlers (ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´)

**ĞÑ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸:**
- ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ (/start, /help, /status)
- Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´
- Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ÑĞ¿Ñ€Ğ°Ğ²Ğ¾Ñ‡Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸
- ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´

**ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹:**
```python
class BotCommandHandlers:
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE)
    async def help(self, update: Update, context: ContextTypes.DEFAULT_TYPE)
    async def status(self, update: Update, context: ContextTypes.DEFAULT_TYPE)
    async def examples(self, update: Update, context: ContextTypes.DEFAULT_TYPE)
```

#### 1.3.4. TelegramResponseFormatter (Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ²)

**ĞÑ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸:**
- ĞĞ´Ğ°Ğ¿Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ° Ğ¿Ğ¾Ğ´ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ Telegram
- Markdown Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
- Ğ Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ğ¸Ğ½Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
- Unicode Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ…Ğ¸Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»

**ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹:**
```python
class TelegramResponseFormatter:
    async def format_response(self, response: str) -> List[str]
    def _split_long_message(self, message: str) -> List[str]
    def _apply_markdown_formatting(self, text: str) -> str
    def _adapt_unicode_symbols(self, text: str) -> str
```

---

## ğŸ”„ 2. ĞŸĞ¾Ñ‚Ğ¾Ğº Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°

### 2.1. Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸

```
User Message (Telegram)
    â†“
1. Message Parsing & Validation
    â”œâ”€ Telegram Update object parsing
    â”œâ”€ Input sanitization & validation
    â””â”€ Query length & content checks
    â†“
2. Command Recognition
    â”œâ”€ Check for system commands (/start, /help, /status)
    â”œâ”€ Extract command parameters if any
    â””â”€ Route to appropriate handler
    â†“
3. Session Management
    â”œâ”€ Create or retrieve user session
    â”œâ”€ Initialize TelegramSessionLogger
    â”œâ”€ Log user request details
    â””â”€ Update session activity tracking
    â†“
4. Pre-processing
    â”œâ”€ Send typing indicator (ChatAction.TYPING)
    â”œâ”€ Validate query format & content
    â””â”€ Check rate limits
    â†“
5. ThermoOrchestrator Integration
    â”œâ”€ orchestrator.process_query(query)
    â”‚   â”œâ”€ ThermodynamicAgent.extract_parameters()
    â”‚   â”œâ”€ Compound Search (SQL Builder)
    â”‚   â”œâ”€ Data Loading & Filtering
    â”‚   â”œâ”€ Thermodynamic Calculations
    â”‚   â””â”€ Response Formatting
    â””â”€ Receive full response string
    â†“
6. Response Processing
    â”œâ”€ Analyze response length & complexity
    â”œâ”€ Determine message vs file strategy
    â”œâ”€ Format for Telegram limitations
    â””â”€ Apply Markdown & Unicode formatting
    â†“
7. Smart Response Delivery
    â”œâ”€ If <3000 chars â†’ Send as message(s)
    â””â”€ If â‰¥3000 chars â†’ Send as TXT file
        â”œâ”€ FileHandler.create_temp_file()
        â”œâ”€ TelegramFileHandler.send_file()
        â””â”€ Send summary message
    â†“
8. Post-processing
    â”œâ”€ Log response metrics
    â”œâ”€ Update session statistics
    â”œâ”€ Cleanup temporary resources
    â””â”€ Error handling & user feedback
```

### 2.2. ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°

**Concurrency Strategy:**
```python
class MessageQueue:
    def __init__(self, max_concurrent=20):
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.processing_tasks = set()
        self.active_sessions = {}

    async def add_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        async with self.semaphore:
            task = asyncio.create_task(self.process_message(update, context))
            self.processing_tasks.add(task)
            task.add_done_callback(self.processing_tasks.discard)
```

**Async Pipeline:**
1. **Input Validation** - ~10ms
2. **Session Setup** - ~5ms
3. **ThermoOrchestrator Processing** - 2000ms-8000ms (Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğµ Ğ²Ñ€ĞµĞ¼Ñ)
4. **Response Formatting** - ~100ms
5. **Delivery** - 100ms-5000ms (Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°)

### 2.3. Error Handling Flow

```
Error Detection
    â†“
Classification
    â”œâ”€ User Input Errors â†’ Immediate feedback
    â”œâ”€ System Errors â†’ Retry logic
    â”œâ”€ External API Errors â†’ Fallback responses
    â””â”€ Critical Errors â†’ Admin notification
    â†“
Recovery Strategy
    â”œâ”€ Retry (max 3 attempts)
    â”œâ”€ Graceful degradation
    â”œâ”€ User-friendly error messages
    â””â”€ Logging & monitoring
```

---

## ğŸ”§ 3. API Ğ¸ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ

### 3.1. Telegram Bot API Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ

#### 3.1.1. Ğ ĞµĞ¶Ğ¸Ğ¼Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹

**Development - Polling Ñ€ĞµĞ¶Ğ¸Ğ¼:**
```python
# Ğ”Ğ»Ñ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¸ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
async def start_polling(self):
    await self.application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True
    )
```

**Production - Webhook Ñ€ĞµĞ¶Ğ¸Ğ¼:**
```python
# Ğ”Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°ĞºÑˆĞµĞ½Ğ°
async def start_webhook(self):
    await self.application.run_webhook(
        listen="0.0.0.0",
        port=8443,
        url_path="telegram",
        webhook_url=self.config.webhook_url,
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True
    )
```

#### 3.1.2. ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğ¹

**Command Handlers:**
```python
# Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
CommandHandler("start", bot_command_handler.start)
CommandHandler("help", bot_command_handler.help)
CommandHandler("calculate", bot_command_handler.calculate)
CommandHandler("status", bot_command_handler.status)
CommandHandler("examples", bot_command_handler.examples)
CommandHandler("about", bot_command_handler.about)

# ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
CommandHandler("admin_status", admin_handler.admin_status)  # Only admin_user_id
CommandHandler("broadcast", admin_handler.broadcast)      # Only admin_user_id
```

**Message Handlers:**
```python
# Ğ¢ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ (Ğ½Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹)
MessageHandler(
    filters.TEXT & ~filters.COMMAND,
    message_handler.handle_text
)

# Callback Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ (inline ĞºĞ½Ğ¾Ğ¿ĞºĞ¸)
CallbackQueryHandler(
    callback_handler.handle_callback,
    pattern=r'^calc_'
)
```

### 3.2. ThermoOrchestrator Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ

#### 3.2.1. ĞĞ´Ğ°Ğ¿Ñ‚ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½

**ThermoAdapter:**
```python
class ThermoAdapter:
    def __init__(self, orchestrator: ThermoOrchestrator):
        self.orchestrator = orchestrator

    async def process_telegram_query(
        self,
        query: str,
        user_session: TelegramSessionLogger
    ) -> str:
        try:
            # Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°
            user_session.log_thermo_request(query)

            # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‡ĞµÑ€ĞµĞ· ThermoOrchestrator
            response = await self.orchestrator.process_query(query)

            # Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°
            user_session.log_thermo_response(len(response))

            return response

        except Exception as e:
            user_session.log_thermo_error(str(e))
            raise
```

#### 3.2.2. Data Flow Integration

**Request Processing:**
```python
async def handle_calculation_request(
    self,
    update: Update,
    context: ContextTypes.DEFAULT_TYPE
) -> None:
    user_query = update.message.text

    with TelegramSessionLogger(
        user_id=update.effective_user.id,
        username=update.effective_user.username
    ) as session_logger:

        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° "calculating"
        await context.bot.send_chat_action(
            chat_id=update.effective_chat.id,
            action=ChatAction.TYPING
        )

        # Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğ° Ñ‡ĞµÑ€ĞµĞ· Ğ°Ğ´Ğ°Ğ¿Ñ‚ĞµÑ€
        response = await self.thermo_adapter.process_telegram_query(
            user_query,
            session_logger
        )

        # Ğ£Ğ¼Ğ½Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°
        await self.smart_response_handler.send_response(
            update, context, response, user_query
        )
```

---

## ğŸ“ 4. Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸

### 4.1. Ğ¡ĞµÑÑĞ¸Ğ¾Ğ½Ğ½Ğ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ

#### 4.1.1. UserSession Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ

```python
@dataclass
class UserSession:
    user_id: int
    username: Optional[str]
    chat_id: int
    start_time: float
    last_activity: float
    request_count: int = 0
    error_count: int = 0
    total_processing_time: float = 0.0

    @property
    def is_active(self) -> bool:
        return time.time() - self.last_activity < 3600  # 1 Ñ‡Ğ°Ñ

    @property
    def session_duration(self) -> float:
        return time.time() - self.start_time

    @property
    def average_processing_time(self) -> float:
        return self.total_processing_time / self.request_count if self.request_count > 0 else 0
```

#### 4.1.2. SessionManager

```python
class SessionManager:
    def __init__(self, max_sessions: int = 1000):
        self.max_sessions = max_sessions
        self.active_sessions: Dict[int, UserSession] = {}
        self.session_stats = defaultdict(int)

    def get_or_create_session(self, user_id: int, username: Optional[str] = None, chat_id: Optional[int] = None) -> UserSession:
        if user_id in self.active_sessions and self.active_sessions[user_id].is_active:
            session = self.active_sessions[user_id]
            session.last_activity = time.time()
            session.request_count += 1
        else:
            session = UserSession(
                user_id=user_id,
                username=username,
                chat_id=chat_id,
                start_time=time.time(),
                last_activity=time.time()
            )
            self.active_sessions[user_id] = session

        self._cleanup_old_sessions()
        return session
```

### 4.2. Rate Limiting

#### 4.2.1. Token Bucket Algorithm

```python
class TokenBucketRateLimiter:
    def __init__(self, capacity: int, refill_rate: float):
        self.capacity = capacity
        self.tokens = capacity
        self.refill_rate = refill_rate
        self.last_refill = time.time()
        self.user_buckets = defaultdict(lambda: {'tokens': capacity, 'last_refill': time.time()})

    async def check_rate_limit(self, user_id: int) -> bool:
        bucket = self.user_buckets[user_id]
        now = time.time()

        # Refill tokens based on time elapsed
        time_passed = now - bucket['last_refill']
        bucket['tokens'] = min(self.capacity, bucket['tokens'] + time_passed * self.refill_rate)
        bucket['last_refill'] = now

        if bucket['tokens'] >= 1:
            bucket['tokens'] -= 1
            return True
        return False
```

#### 4.2.2. Global Rate Limiting

```python
class GlobalRateLimiter:
    def __init__(self, requests_per_minute: int = 30):
        self.requests_per_minute = requests_per_minute
        self.request_timestamps = deque()
        self._lock = asyncio.Lock()

    async def check_global_limit(self) -> bool:
        async with self._lock:
            now = time.time()
            # Remove old requests (older than 1 minute)
            while self.request_timestamps and now - self.request_timestamps[0] > 60:
                self.request_timestamps.popleft()

            if len(self.request_timestamps) < self.requests_per_minute:
                self.request_timestamps.append(now)
                return True
            return False
```

---

## ğŸ”„ 5. ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹

### 5.1. Message Pipeline

#### 5.1.1. Input Validation

```python
class QueryValidator:
    MAX_QUERY_LENGTH = 1000
    FORBIDDEN_PATTERNS = [
        r'<script[^>]*>.*?</script>',
        r'javascript:',
        r'http[s]?://',
        r'--',  # SQL injection
        r'/\*.*?\*/'  # SQL comments
    ]

    @staticmethod
    def validate_query(query: str) -> ValidationResult:
        # Length validation
        if len(query) > QueryValidator.MAX_QUERY_LENGTH:
            return ValidationResult(
                is_valid=False,
                error=f"Query too long (max {QueryValidator.MAX_QUERY_LENGTH} chars)"
            )

        # Security validation
        for pattern in QueryValidator.FORBIDDEN_PATTERNS:
            if re.search(pattern, query, re.IGNORECASE):
                return ValidationResult(
                    is_valid=False,
                    error="Query contains forbidden content"
                )

        # Chemical formula validation (basic)
        if not QueryValidator._has_chemical_content(query):
            return ValidationResult(
                is_valid=False,
                error="Query doesn't contain recognizable chemical content"
            )

        return ValidationResult(is_valid=True)
```

### 5.2. Response Processing

#### 5.2.1. Smart Response Strategy

```python
class SmartResponseHandler:
    def __init__(self, file_handler: TelegramFileHandler, message_threshold: int = 3000):
        self.file_handler = file_handler
        self.message_threshold = message_threshold

    async def send_response(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        response: str,
        query: str = ""
    ) -> bool:
        try:
            should_use_file = self._should_use_file(response)

            if should_use_file:
                return await self._send_as_file(update, context, response, query)
            else:
                return await self._send_as_messages(update, context, response)

        except Exception as e:
            logger.error(f"Error sending response: {e}")
            await self._send_error_message(update, context, str(e))
            return False

    def _should_use_file(self, response: str) -> bool:
        return (
            len(response) >= self.message_threshold or
            self._has_large_tables(response) or
            self._has_complex_formatting(response)
        )
```

---

## ğŸ¯ 6. Component Dependencies

### 6.1. Dependency Injection

```python
@dataclass
class TelegramBotDependencies:
    orchestrator: ThermoOrchestrator
    config: TelegramBotConfig
    session_manager: SessionManager
    rate_limiter: RateLimiter
    file_handler: TelegramFileHandler
    response_formatter: TelegramResponseFormatter
    smart_response_handler: SmartResponseHandler

class ThermoSystemTelegramBot:
    def __init__(self, deps: TelegramBotDependencies):
        self.deps = deps
        self.application = Application.builder().token(deps.config.bot_token).build()
        self._setup_handlers()
```

### 6.2. Configuration Management

```python
@dataclass
class TelegramBotConfig:
    # Telegram API
    bot_token: str
    bot_username: str
    webhook_url: Optional[str] = None
    mode: str = "polling"

    # Performance
    max_concurrent_users: int = 20
    request_timeout_seconds: int = 60
    message_max_length: int = 4000

    # Features
    enable_file_downloads: bool = True
    auto_file_threshold: int = 3000
    enable_analytics: bool = True

    # Security
    admin_user_id: Optional[int] = None
    log_errors_to_admin: bool = True

    @classmethod
    def from_env(cls) -> 'TelegramBotConfig':
        return cls(
            bot_token=os.getenv("TELEGRAM_BOT_TOKEN", ""),
            bot_username=os.getenv("TELEGRAM_BOT_USERNAME", "ThermoCalcBot"),
            webhook_url=os.getenv("TELEGRAM_WEBHOOK_URL"),
            mode=os.getenv("TELEGRAM_MODE", "polling"),
            max_concurrent_users=int(os.getenv("MAX_CONCURRENT_USERS", "20")),
            enable_file_downloads=os.getenv("ENABLE_FILE_DOWNLOADS", "true").lower() == "true",
            auto_file_threshold=int(os.getenv("AUTO_FILE_THRESHOLD", "3000")),
            admin_user_id=int(os.getenv("TELEGRAM_ADMIN_USER_ID", "0")) if os.getenv("TELEGRAM_ADMIN_USER_ID") else None
        )
```

---

## ğŸ“ˆ 7. Performance Optimizations

### 7.1. Caching Strategy

```python
class ResponseCache:
    def __init__(self, ttl_seconds: int = 3600):
        self.cache = {}
        self.ttl = ttl_seconds

    async def get_cached_response(self, query_hash: str) -> Optional[str]:
        if query_hash in self.cache:
            cached_data = self.cache[query_hash]
            if time.time() - cached_data['timestamp'] < self.ttl:
                return cached_data['response']
            else:
                del self.cache[query_hash]
        return None

    async def cache_response(self, query_hash: str, response: str):
        self.cache[query_hash] = {
            'response': response,
            'timestamp': time.time()
        }
```

### 7.2. Connection Pooling

```python
class DatabaseConnectionPool:
    def __init__(self, db_path: str, max_connections: int = 10):
        self.db_path = db_path
        self.max_connections = max_connections
        self.pool = asyncio.Queue(maxsize=max_connections)
        self._pool_initialized = False

    async def initialize_pool(self):
        if not self._pool_initialized:
            for _ in range(self.max_connections):
                conn = sqlite3.connect(self.db_path, check_same_thread=False)
                await self.pool.put(conn)
            self._pool_initialized = True

    async def get_connection(self):
        return await self.pool.get()

    async def return_connection(self, conn):
        await self.pool.put(conn)
```

---

## ğŸ“‹ 8. Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ ÑˆĞ°Ğ³Ğ¸

ĞŸĞ¾ÑĞ»Ğµ Ğ¸Ğ·ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñ‹ Ğ¿ĞµÑ€ĞµĞ¹Ğ´Ğ¸Ñ‚Ğµ Ğº Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñƒ **[04_file_handling_system.md](./04_file_handling_system.md)** Ğ´Ğ»Ñ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¾Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¾Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ¸ ÑƒĞ¼Ğ½Ñ‹Ğ¼Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°Ğ¼Ğ¸.

---

**Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚ Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ»ĞµĞ½ Ğ´Ğ»Ñ:** System Architects Ğ¸ Senior Python Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¾Ğ²
**Ğ¦ĞµĞ»ĞµĞ²Ğ°Ñ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ:** ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ThermoSystem
**Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñ‹:** Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ-Ğ’Ñ‹ÑĞ¾ĞºĞ°Ñ (async, concurrency, distributed systems)