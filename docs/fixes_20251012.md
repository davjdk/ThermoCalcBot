# Исправления ошибок в многоагентной системе термодинамических агентов
## Дата: 12 октября 2025

На основании анализа лог-файла `session_20251012_123247.log` были выявлены и исправлены критические проблемы в системе.

## Выявленные проблемы

### 1. Timeout Filtering Agent
- **Проблема:** Filtering Agent timeout после 180 секунд
- **Следствие:** Система не завершала обработку запросов, Individual Search Agent не получал результаты
- **Причина:** Недостаточные таймауты для сложных запросов

### 2. SQL-evaluation ошибки
- **Проблема:** Множественные ошибки `invalid syntax` при evaluate conditions
- **Пример ошибки:** `TRIM(Formula) = 'CeO2' AND Phase = 's' AND (673.15 >= Tmin AND 673.15 <= Tmax) AND ReliabilityClass = 1`
- **Причина:** Некорректная конвертация SQL в Python expressions

### 3. Неправильная обработка fallback
- **Проблема:** Система использовала fallback к сырым результатам базы данных вместо повторных запросов
- **Требование:** Fallback должен быть только функционалом отбрасывания старого запроса и повторного запроса (максимум 2 попытки)

### 4. Отсутствие полного поиска
- **Проблема:** Не для всех веществ был проведен полный поиск в базе данных
- **Причина:** Преждевременное завершение из-за таймаутов

## Внесенные исправления

### 1. Исправлен механизм fallback в Results Filtering Agent

**Файл:** `src/thermo_agents/results_filtering_agent.py`

#### Изменения:
- Добавлен параметр `retry_count` в метод `_process_message`
- Реализован механизм повторных запросов с максимум 2 попытками
- Добавлен экспоненциальный backoff (1с, 2с, максимум 5с)
- Добавлен метод `_should_retry_request` для определения необходимости повторения

#### Ключевой код:
```python
async def _process_message(self, message, retry_count: int = 0):
    # Механизм повторных запросов - максимум 2 попытки
    if retry_count < 2:
        should_retry = self._should_retry_request(e, retry_count)
        if should_retry:
            retry_delay = min(2 ** retry_count, 5)  # Экспоненциальный backoff
            await asyncio.sleep(retry_delay)
            await self._process_message(message, retry_count + 1)
```

### 2. Устранены SQL-evaluation ошибки

#### Изменения:
- Полностью переписан метод `_evaluate_condition_safely`
- Добавлен метод `_convert_sql_to_python` для корректной конвертации SQL → Python
- Добавлен метод `_create_safe_evaluation_context` для безопасного контекста eval
- Улучшена обработка TRIM функций и LIKE условий

#### Ключевой код:
```python
def _convert_sql_to_python(self, condition: str, context: Dict[str, Any]) -> str:
    # Корректная замена SQL операторов
    replacements = [
        (" >= ", " >= "),
        (" <= ", " <= "),
        (" = ", " == "),
        (" AND ", " and "),
        (" OR ", " or "),
        (" IS NULL ", " is None "),
        (" IS NOT NULL ", " is not None "),
    ]

    # Обработка TRIM функции
    python_condition = python_condition.replace("TRIM(", "_trim_function(")
```

### 3. Оптимизированы таймауты Filtering Agent

#### Изменения в конфигурации:
```python
@dataclass
class ResultsFilteringAgentConfig:
    filtering_timeout: int = 240  # Увеличено с 180 до 240 секунд
    sql_generation_timeout: int = 45  # Таймаут для генерации SQL фильтров
    llm_filtering_timeout: int = 60  # Таймаут для LLM фильтрации
    max_retry_attempts: int = 2  # Максимальное количество повторных запросов
```

### 4. Реализован механизм request abandonment при таймауте

#### Изменения:
- Добавлен метод `_abandon_request_if_timeout`
- Интегрирована проверка таймаута в основной цикл обработки
- Отправляется сообщение `filtering_abandoned` при превышении таймаута

#### Ключевой код:
```python
async def _abandon_request_if_timeout(self, correlation_id: str, start_time: float) -> bool:
    elapsed = asyncio.get_event_loop().time() - start_time
    if elapsed > self.config.filtering_timeout:
        # Отправляем сообщение об отмене запроса
        self.storage.send_message(
            message_type="filtering_abandoned",
            payload={"status": "abandoned", "reason": f"Request timeout after {elapsed:.1f}s"}
        )
        return True
    return False
```

### 5. Усилено логирование и мониторинг системы

#### Изменения:
- Добавлено детальное логирование всех этапов обработки с метриками времени
- Добавлены методы `get_status()` и `get_diagnostics()` для мониторинга
- Добавлен health-check функционал
- Добавлены метрики производительности (CPU, memory, storage)

#### Ключевой код:
```python
def get_diagnostics(self) -> Dict:
    return {
        "system_metrics": {
            "cpu_percent": process.cpu_percent(),
            "memory_mb": process.memory_info().rss / 1024 / 1024,
            "memory_percent": process.memory_percent(),
        },
        "health_check": {
            "storage_accessible": self._test_storage_access(),
            "logger_functional": self._test_logger_functionality(),
            "agent_responsive": self.running,
        }
    }
```

## Дополнительные изменения

### Обновлены зависимости
- Добавлен `psutil>=5.9.0` в `pyproject.toml` для системного мониторинга

### Улучшена обработка ошибок
- Детальная классификация ошибок (retryable vs non-retryable)
- Логирование всех попыток повторных запросов
- Расширенная информация об ошибках в ответах

## Ожидаемые результаты

1. **Исключение fallback к сырым данным:** Система теперь использует только повторные запросы
2. **Полный поиск всех веществ:** Увеличенные таймауты позволяют завершить полный поиск
3. **Сокращение таймаутов:** Оптимизированная обработка SQL условий
4. **Повышение надежности:** Правильная обработка ошибок и повторные запросы
5. **Улучшенный мониторинг:** Детальные метрики и health-check функционал

## Тестирование

Для тестирования изменений рекомендуется:
1. Запустить систему с запросом "Может ли провзаимодействовать оксид церия с хлоридом аммония при 400 цельсия?"
2. Проверить, что система завершается без ошибок таймаута
3. Убедиться, что все вещества найдены и обработаны корректно
4. Проверить логи на наличие retry-попыток и метрик производительности

## Обновленная архитектура

```
User Query → Orchestrator → Thermodynamic Agent → Individual Search Agent
     ↓
SQL Generation (timeout: 45s) → Database Agent → Results Filtering Agent (timeout: 240s)
     ↓
Retry Logic (max 2 attempts) → Individual Search Agent → User Response
```

Система теперь готова к обработке сложных запросов с улучшенной надежностью и мониторингом.